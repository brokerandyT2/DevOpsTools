using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;

namespace x3squaredcircles.DataLink.Container.Weavers
{
    public class CSharpGcpFunctionsWeaver : CSharpWeaverBase
    {
        public CSharpGcpFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
            : base(logger, blueprint) { }

        public override async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var requiredPackages = new HashSet<string>
            {
                "Google.Cloud.Functions.Hosting",
                "Microsoft.AspNetCore.Http" // Needed for HttpContext interaction
            };

            var packageReferences = string.Join("\n", requiredPackages.Select(p =>
                $@"    <PackageReference Include=""{p}"" Version=""{GetPackageVersion(p)}"" />"));

            var logicProjectFilePath = Directory.GetFiles(logicSourcePath, "*.csproj", SearchOption.AllDirectories).FirstOrDefault();
            if (logicProjectFilePath == null) throw new DataLinkException(ExitCode.SourceAnalysisFailed, "LOGIC_CSPROJ_NOT_FOUND", "Could not find a .csproj file in the business logic source path.");
            var relativeLogicPath = Path.GetRelativePath(projectPath, logicProjectFilePath);

            var csprojContent = $@"
<Project Sdk=""Microsoft.NET.Sdk.Web"">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <OutputType>Exe</OutputType>
    <RootNamespace>{_blueprint.ServiceName}</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
{packageReferences}
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include=""{relativeLogicPath}"" />
  </ItemGroup>
</Project>";
            await File.WriteAllTextAsync(Path.Combine(projectPath, $"{_blueprint.ServiceName}.csproj"), csprojContent.Trim());
        }

        public override async Task GenerateStartupFileAsync(string projectPath)
        {
            var allRequiredServices = GetAllRequiredServices();
            var diRegistrations = string.Join(Environment.NewLine, allRequiredServices.Select(cls => $"            services.AddTransient<{cls}>();"));
            var usingStatements = GenerateFileHeader(allRequiredServices);

            var startupContent = $@"
using Microsoft.Extensions.DependencyInjection;
using Google.Cloud.Functions.Hosting;
{usingStatements}
using {_blueprint.ServiceName};

[assembly: FunctionsStartup(typeof({_blueprint.ServiceName}.Generated.Startup))]

namespace {_blueprint.ServiceName}.Generated
{{
    public class Startup : FunctionsStartup
    {{
        public override void ConfigureServices(WebHostBuilderContext context, IServiceCollection services)
        {{
            // Register developer-defined handler, hook, and dependency classes
{diRegistrations}
        }}
    }}
}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "Startup.cs"), startupContent.Trim());
        }

        public override async Task GeneratePlatformFilesAsync(string projectPath)
        {
            _logger.LogInfo("Generating 'cloudbuild.yaml' for GCP deployment...");

            // The entry point for a GCP function is the fully-qualified name of the class that implements IHttpFunction.
            var entryPoint = $"{_blueprint.ServiceName}.Generated.{_blueprint.TriggerMethods.First().MethodName}";
            var serviceName = _blueprint.ServiceName.ToLowerInvariant();

            // The cloudbuild.yaml file defines the CI/CD steps for GCP.
            // It uses placeholders like $_GCP_PROJECT and $_GCP_REGION which are standard
            // substitution variables provided by Google Cloud Build triggers.
            var cloudBuildContent = $@"
# Auto-generated by 3SC API Assembler
# This file defines the build, containerization, and deployment steps for Google Cloud Build.
steps:
# 1. Restore .NET dependencies
- name: 'gcr.io/cloud-builders/dotnet'
  args: ['restore']
  id: 'dotnet-restore'

# 2. Publish the .NET application
- name: 'gcr.io/cloud-builders/dotnet'
  args: ['publish', '-c', 'Release', '-o', 'published']
  id: 'dotnet-publish'
  waitFor: ['dotnet-restore']

# 3. Build the runtime container using Google Cloud Buildpacks
# This step automatically containerizes the published .NET app without a Dockerfile.
- name: 'gcr.io/k8s-skaffold/pack'
  args:
  - 'build'
  - '$_GCP_REGION-docker.pkg.dev/$_GCP_PROJECT/cloud-functions-containers/{serviceName}:$SHORT_SHA'
  - '--builder=gcr.io/buildpacks/builder:v1'
  - '--path=./published'
  id: 'build-container'
  waitFor: ['dotnet-publish']

# 4. Push the container image to Google Artifact Registry
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', '$_GCP_REGION-docker.pkg.dev/$_GCP_PROJECT/cloud-functions-containers/{serviceName}:$SHORT_SHA']
  id: 'push-container'
  waitFor: ['build-container']

# 5. Deploy the container to Google Cloud Functions (2nd Gen)
# This creates or updates the serverless function.
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  entrypoint: 'gcloud'
  args:
    - 'functions'
    - 'deploy'
    - '{serviceName}'
    - '--gen2'
    - '--region=$_GCP_REGION'
    - '--runtime=dotnet8'
    - '--source=.'
    - '--entry-point={entryPoint}'
    - '--trigger-http'
    - '--allow-unauthenticated'
    - '--project=$_GCP_PROJECT'
  id: 'deploy-function'
  waitFor: ['push-container']

# Define the final container image name for reference in other parts of the build.
images:
- '$_GCP_REGION-docker.pkg.dev/$_GCP_PROJECT/cloud-functions-containers/{serviceName}:$SHORT_SHA'
";

            var filePath = Path.Combine(projectPath, "cloudbuild.yaml");
            await File.WriteAllTextAsync(filePath, cloudBuildContent.Trim());
            _logger.LogDebug($"Generated 'cloudbuild.yaml' at: {filePath}");
        }

        public override async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            // For GCP, the class name in the source code becomes the function entry point.
            var functionClassName = triggerMethod.MethodName;
            var handlerVarName = $"_{ToCamelCase(_blueprint.HandlerClassFullName.Split('.').Last())}";

            var diServices = new Dictionary<string, string> { { _blueprint.HandlerClassFullName, handlerVarName } };
            foreach (var service in GetAllRequiredServices().Where(s => s != _blueprint.HandlerClassFullName))
            {
                diServices.TryAdd(service, $"_{ToCamelCase(service.Split('.').Last())}");
            }
            diServices.TryAdd($"ILogger<{functionClassName}>", "_logger");

            var ctorParams = string.Join(", ", diServices.Select(kvp => $"{kvp.Key} {kvp.Value.TrimStart('_')}"));
            var ctorAssignments = string.Join(Environment.NewLine, diServices.Select(kvp => $"        {kvp.Value} = {kvp.Value.TrimStart('_')};"));

            // GCP HTTP Functions are simpler and don't use attributes on parameters.
            // We assume the payload is the first non-DI parameter.
            var payloadParam = triggerMethod.Parameters.FirstOrDefault(p => !p.IsBusinessLogicDependency);
            if (payloadParam == null) throw new DataLinkException(ExitCode.CodeGenerationFailed, "GCP_PAYLOAD_NOT_FOUND", $"GCP Function '{triggerMethod.MethodName}' requires a payload parameter.");

            var businessLogicCallParams = string.Join(", ", triggerMethod.Parameters.Select(p => p.IsBusinessLogicDependency ? diServices[p.TypeFullName] : p.Name));

            var allUsingTypes = triggerMethod.Parameters.Select(p => p.TypeFullName).Concat(diServices.Keys);

            var functionContent = $@"
using Google.Cloud.Functions.Framework;
using Microsoft.AspNetCore.Http;
using System.Text.Json;
{GenerateFileHeader(allUsingTypes)}
using {_blueprint.ServiceName};

namespace {_blueprint.ServiceName}.Generated
{{
    public class {functionClassName} : IHttpFunction
    {{
{string.Join(Environment.NewLine, diServices.Select(kvp => $"        private readonly {kvp.Key} {kvp.Value};"))}

        public {functionClassName}({ctorParams})
        {{
{ctorAssignments}
        }}

        public async Task HandleAsync(HttpContext context)
        {{
            _logger.LogInformation(""GCP shim function '{functionClassName}' is invoking the business logic."");
            
            var {payloadParam.Name} = await JsonSerializer.DeserializeAsync<{payloadParam.TypeFullName}>(context.Request.Body);
            if({payloadParam.Name} == null)
            {{
                context.Response.StatusCode = 400; // Bad Request
                await context.Response.WriteAsync(""Invalid payload."");
                return;
            }}

            var result = await {handlerVarName}.{triggerMethod.MethodName}({businessLogicCallParams});

            context.Response.ContentType = ""application/json"";
            await context.Response.WriteAsync(JsonSerializer.Serialize(result));
        }}
    }}
}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, $"{functionClassName}.cs"), functionContent.Trim());
        }

        protected override async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testProjectPath)
        {
            // Placeholder for GCP test harness generation.
            await Task.CompletedTask;
        }

        private string GetPackageVersion(string packageName)
        {
            return packageName switch
            {
                "Google.Cloud.Functions.Hosting" => "2.1.0",
                "Microsoft.AspNetCore.Http" => "2.2.2", // A common compatible version
                _ => "1.0.0"
            };
        }
    }
}