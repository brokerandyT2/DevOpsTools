using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a TypeScript AWS Lambda project using SAM.
    /// </summary>
    public class TypeScriptAwsLambdaWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public TypeScriptAwsLambdaWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var devDependencies = new StringBuilder();
            devDependencies.AppendLine(@"    ""@types/aws-lambda"": ""^8.10.137"",");
            devDependencies.AppendLine(@"    ""@types/jest"": ""^29.5.12"",");
            devDependencies.AppendLine(@"    ""@types/node"": ""^20.12.7"",");
            devDependencies.AppendLine(@"    ""esbuild"": ""^0.20.2"",");
            devDependencies.AppendLine(@"    ""jest"": ""^29.7.0"",");
            devDependencies.AppendLine(@"    ""ts-jest"": ""^29.1.2"",");
            devDependencies.AppendLine(@"    ""typescript"": ""^5.4.5""");

            var packageJsonContent = $@"
{{
  ""name"": ""{_blueprint.ServiceName}"",
  ""version"": ""1.0.0"",
  ""description"": ""Auto-generated by 3SC DataLink"",
  ""main"": ""dist/handler.js"",
  ""scripts"": {{
    ""build"": ""esbuild src/handler.ts --bundle --minify --sourcemap --platform=node --target=es2020 --outfile=dist/handler.js"",
    ""test"": ""jest""
  }},
  ""devDependencies"": {{
{devDependencies.ToString().TrimEnd(',')}
  }},
  ""dependencies"": {{ }}
}}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "package.json"), packageJsonContent.Trim());

            var tsConfigContent = @"{
  ""compilerOptions"": {
    ""target"": ""ES2020"",
    ""strict"": true,
    ""module"": ""commonjs"",
    ""esModuleInterop"": true,
    ""outDir"": ""dist""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "tsconfig.json"), tsConfigContent.Trim());

            var jestConfigContent = @"module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "jest.config.js"), jestConfigContent.Trim());
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            // TypeScript/Node.js on Lambda uses a simple handler file, not a complex startup class.
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var resources = new StringBuilder();
            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                var trigger = triggerMethod.Triggers.First();
                var handlerPath = $"dist/handler.{triggerMethod.MethodName}";
                var (eventType, eventProperties) = GetSamEvent(trigger);

                resources.AppendLine($@"  {triggerMethod.MethodName}Function:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Zip
      CodeUri: .
      Handler: {handlerPath}
      Runtime: nodejs20.x
      Architectures: [ x86_64 ]
      Events:
        Trigger:
          Type: {eventType}
          Properties:
{eventProperties}");
            }

            var samTemplateContent = $@"
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  {_blueprint.ServiceName} - Auto-generated by 3SC DataLink from source version {_blueprint.Metadata.SourceVersionTag}

Resources:
{resources.ToString().TrimEnd()}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "template.yaml"), samTemplateContent.Trim());
        }

        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var srcPath = Path.Combine(projectPath, "src");
            Directory.CreateDirectory(srcPath);

            var payload = triggerMethod.Parameters.First(p => p.IsPayload);
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerVarName = ToCamelCase(handlerClassName);
            var (awsEventType, payloadExtraction) = GetAwsEventType(triggerMethod.Triggers.First());

            var handlerContent = $@"
import {{ {awsEventType} }} from 'aws-lambda';
// import {{ {handlerClassName} }} from '../business-logic'; // Developer needs to configure path to their logic
// import {{ {payload.TypeFullName} }} from '../business-logic/dtos'; // Developer needs to configure path to their DTOs

// Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}

// In a real application, dependency injection would be set up here.
// const {handlerVarName} = new {handlerClassName}();

export const {triggerMethod.MethodName} = async (event: {awsEventType}): Promise<any> => {{
    try {{
        // Logic to extract and parse the payload from the specific event type
        const payload: {payload.TypeFullName} = {payloadExtraction};

        // Weave [Requires] hooks (pre-processing gates like auth)
        
        // Weave [RequiresLogger] OnInbound hooks
        console.log(`Processing payload:`, payload);

        // Invoke business logic
        // await {handlerVarName}.{ToCamelCase(triggerMethod.MethodName)}(payload);
        
        return {{
            statusCode: 200,
            body: JSON.stringify({{ message: 'Request processed successfully.' }})
        }};
    }} catch (error) {{
        // Weave [RequiresLogger] OnError hooks
        console.error('An error occurred:', error);
        return {{
            statusCode: 500,
            body: JSON.stringify({{ message: 'An error occurred.' }})
        }};
    }}
}};
";
            await File.WriteAllTextAsync(Path.Combine(srcPath, "handler.ts"), handlerContent.Trim());
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
        {
            _logger.LogInfo("Assembling TypeScript test harness project...");
            var testSrcPath = Path.Combine(testProjectPath, "tests");
            Directory.CreateDirectory(testSrcPath);

            var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
            var relevantTestFiles = Directory.GetFiles(testSourcePath, $"*{handlerClassNameShort}.test.ts", SearchOption.AllDirectories);
            foreach (var testFile in relevantTestFiles)
            {
                File.Copy(testFile, Path.Combine(testSrcPath, Path.GetFileName(testFile)), true);
            }

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                await GenerateSingleTestHarnessFileAsync(triggerMethod, testSrcPath);
            }
        }

        private async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var handlerModuleName = "handler";
            var businessLogicModuleName = ToCamelCase(_blueprint.HandlerClassFullName.Split('.').Last());
            var harnessFileName = $"handler.{triggerMethod.MethodName}.harness.test.ts";

            var harnessContent = $@"
import * as handler from '../../src/{handlerModuleName}';
// Mock the entire business logic module
// jest.mock('../business-logic');
// import {{ {businessLogicModuleName} }} from '../business-logic';

describe('{triggerMethod.MethodName} harness', () => {{
    it('should invoke the business logic handler', () => {{
        // This test will fail here until you implement the mock setups and assertions.
        throw new Error('Test not yet implemented. Please configure mocks and add assertions, then remove this line.');

        /* --- EXAMPLE IMPLEMENTATION ---
        // Arrange
        const mockBusinessLogicInstance = {businessLogicModuleName}.mock.instances[0];
        const mockMethod = mockBusinessLogicInstance.{ToCamelCase(triggerMethod.MethodName)};
        
        const mockEvent = {{
            body: JSON.stringify({{ key: 'value' }})
        }};
        
        // Act
        // await handler.{triggerMethod.MethodName}(mockEvent);
        
        // Assert
        // expect(mockMethod).toHaveBeenCalledTimes(1);
        */
    }});
}});
";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private (string EventType, string PayloadExtraction) GetAwsEventType(TriggerDefinition trigger)
        {
            switch (trigger.Type)
            {
                case "Http":
                    return ("APIGatewayProxyEvent", "JSON.parse(event.body || '{}')");
                case "AwsSqsQueue":
                    // SQS Batch processing would be more complex
                    return ("SQSEvent", "JSON.parse(event.Records[0].body)");
                default:
                    return ("any", "event");
            }
        }

        private string ToCamelCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return char.ToLowerInvariant(input[0]) + input.Substring(1);
        }
    }
}