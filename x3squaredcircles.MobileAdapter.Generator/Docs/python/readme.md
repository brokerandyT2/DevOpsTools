
# Using the Mobile Adapter Generator with Python

This document provides a comprehensive guide for generating native mobile data models from a Python codebase, leveraging type hints for accuracy.

## 1. Core Concept: Source File Analysis

The generator works with Python by parsing `.py` source files directly. It looks for class definitions marked with a specific decorator and analyzes their class-level attributes or `__init__` methods for properties defined with **PEP 484 type hints**.

**This is a critical point:** While Python is dynamically typed, providing type hints is essential for the generator to produce accurate and useful native mobile models.

## 2. How to Mark Classes for Discovery

The recommended method is to use a simple, custom decorator. This allows you to explicitly mark which classes should be processed.

#### Step 1: Define the Tracking Decorator in a Shared Utility File
Create a utility file in your project (e.g., `utils/tracking.py`) to define the decorator.

```python
# utils/tracking.py
def trackable_dto(cls):
    """A simple identity decorator to mark classes for the mobile adapter generator."""
    return cls
Step 2: Apply the Decorator to Your DTOs
Now, import and apply this decorator to any class you want the generator to discover. Use standard Python type hints to define your properties.
code
Python
from datetime import datetime
from typing import List, Dict, Optional
from uuid import UUID
from .utils.tracking import trackable_dto

@trackable_dto
class TripPlan:
    # Class-level attributes with type hints are discovered
    id: UUID
    destination: str
    start_date: datetime
    end_date: datetime
    is_confirmed: bool
    budget: float
    travelers: List[str]
    details: Optional[Dict[str, str]] # Optional notes

    # You can also define them in __init__
    def __init__(self, id: UUID, destination: str, ...):
        self.id = id
        self.destination = destination
        # ...
Key Points:
The decorator's name must match the TRACK_ATTRIBUTE configuration.
Properties can be defined at the class level or within __init__. Class-level is generally cleaner and preferred.
Use standard types from Python's typing module, such as List, Dict, and Optional, for best results.
3. Configuration
You must configure the generator using environment variables in your CI/CD pipeline.
Crucial Python Variables:
LANGUAGE_PYTHON: Must be set to true.
TRACK_ATTRIBUTE: The name of the decorator you created (e.g., trackable_dto).
PYTHON_PATHS: A semicolon-separated list of paths inside the container where your .py source files are located.
Example Configuration for Android (Kotlin) Generation
code
Bash
# 1. Language and Platform
LANGUAGE_PYTHON=true
PLATFORM_ANDROID=true

# 2. Discovery Method
# Find all classes with the @trackable_dto decorator
TRACK_ATTRIBUTE=trackable_dto

# 3. Source Path (CRITICAL)
# Path to the directory containing your Python models
PYTHON_PATHS=/src/my_project/models

# 4. Core Config
REPO_URL="https://github.com/my-org/my-python-backend"
BRANCH="master"
LICENSE_SERVER="https://license.my-company.com"

# 5. Output Config
OUTPUT_DIR=/src/generated-mobile-models
ANDROID_OUTPUT_DIR=./android
ANDROID_PACKAGE_NAME="com.mycompany.app.models"
Example Configuration for iOS (Swift) Generation
Note the change in PLATFORM_* and output variables.
code
Bash
# 1. Language and Platform
LANGUAGE_PYTHON=true
PLATFORM_IOS=true

# 2. Discovery Method
TRACK_ATTRIBUTE=trackable_dto

# 3. Source Path (CRITICAL)
PYTHON_PATHS=/src/my_project/models

# 4. Core Config
REPO_URL="https://github.com/my-org/my-python-backend"
BRANCH="master"
LICENSE_SERVER="https://license.my-company.com"

# 5. Output Config
OUTPUT_DIR=/src/generated-mobile-models
IOS_OUTPUT_DIR=./ios
IOS_MODULE_NAME="SharedModels"
4. Expected Output
Based on the Python example above, the generator will produce the following file.
Generated Kotlin (TripPlan.kt)
code
Kotlin
package com.mycompany.app.models

import java.time.LocalDateTime
import java.util.UUID

data class TripPlan(
    val id: UUID,
    val destination: String,
    val startDate: LocalDateTime,
    val endDate: LocalDateTime,
    val isConfirmed: Boolean,
    val budget: Double,
    val travelers: List<String>,
    val details: Map<String, String>?
)
Generated Swift (TripPlan.swift)
code
Swift
// Generated by 3SC Mobile Adapter Generator
import Foundation

struct TripPlan: Codable {
    let id: UUID
    let destination: String
    let startDate: Date
    let endDate: Date
    let isConfirmed: Bool
    let budget: Double
    let travelers: [String]
    let details: [String: String]?
}
5. Type Mapping Reference
The following table shows how common Python types are mapped to their Kotlin and Swift equivalents.
Python Type	Kotlin Type	Swift Type
str	String	String
int	Long	Int64
float	Double	Double
bool	Boolean	Bool
datetime	LocalDateTime	Date
UUID	UUID	UUID
bytes	ByteArray	Data
List[T] or list[T]	List<T>	[T]
Dict[K,V] or dict[K,V]	Map<K,V>	[K:V]
Optional[T]	T?	T?
Any	Any	Any
6. Troubleshooting
Error: No classes found.
Is PYTHON_PATHS correct? The path must point to your Python package directory within the container's /src volume mount.
Does the decorator name match? The string in TRACK_ATTRIBUTE must exactly match the name of your decorator function (e.g., trackable_dto).
Are you using type hints? While the generator may find classes without them, the generated properties will be inaccurate (Any/Any?).
Is the decorator directly above the class keyword?