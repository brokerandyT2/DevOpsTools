using System;
using System.IO;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a TypeScript OCI Functions project using the Fn Project FDK.
    /// </summary>
    public class TypeScriptOciFunctionsWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public TypeScriptOciFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var devDependencies = new StringBuilder();
            devDependencies.AppendLine(@"    ""@types/jest"": ""^29.5.12"",");
            devDependencies.AppendLine(@"    ""@types/node"": ""^20.12.7"",");
            devDependencies.AppendLine(@"    ""jest"": ""^29.7.0"",");
            devDependencies.AppendLine(@"    ""ts-jest"": ""^29.1.2"",");
            devDependencies.AppendLine(@"    ""typescript"": ""^5.4.5""");

            var dependencies = new StringBuilder();
            dependencies.AppendLine(@"    ""@fnproject/fdk"": ""^0.0.19""");

            var packageJsonContent = $@"
{{
  ""name"": ""{_blueprint.ServiceName.ToLowerInvariant()}"",
  ""version"": ""1.0.0"",
  ""description"": ""Auto-generated by 3SC DataLink"",
  ""main"": ""dist/func.js"",
  ""scripts"": {{
    ""build"": ""tsc"",
    ""prestart"": ""npm run build"",
    ""start"": ""node dist/func.js"",
    ""test"": ""jest""
  }},
  ""dependencies"": {{
{dependencies.ToString().TrimEnd(',')}
  }},
  ""devDependencies"": {{
{devDependencies.ToString().TrimEnd(',')}
  }}
}}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "package.json"), packageJsonContent.Trim());

            var tsConfigContent = @"{
  ""compilerOptions"": {
    ""target"": ""ES2020"",
    ""module"": ""commonjs"",
    ""strict"": true,
    ""esModuleInterop"": true,
    ""outDir"": ""dist"",
    ""rootDir"": ""src""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "tsconfig.json"), tsConfigContent.Trim());

            var jestConfigContent = @"module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts']
};";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "jest.config.js"), jestConfigContent.Trim());
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var funcYamlContent = $@"
schema_version: 20180708
name: {_blueprint.ServiceName.ToLowerInvariant()}
version: {_blueprint.Metadata.SourceVersionTag.TrimStart('v')}
runtime: node
entrypoint: node dist/func.js
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "func.yaml"), funcYamlContent.Trim());

            var dockerfileContent = $@"
# Auto-generated by 3SC DataLink
# Source Version: {_blueprint.Metadata.SourceVersionTag}
FROM fnproject/node:18-dev as build-stage
WORKDIR /function
ADD package*.json /function/
RUN npm install
ADD . /function/
RUN npm run build

FROM fnproject/node:18
WORKDIR /function
COPY --from=build-stage /function/dist ./dist
COPY --from=build-stage /function/node_modules ./node_modules
ENTRYPOINT [""node"", ""dist/func.js""]
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "Dockerfile"), dockerfileContent.Trim());
        }

        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var srcPath = Path.Combine(projectPath, "src");
            Directory.CreateDirectory(srcPath);

            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var payload = triggerMethod.Parameters.First(p => p.IsPayload);

            var funcTsContent = $@"
import * as fdk from '@fnproject/fdk';
// import {{ {handlerClassName} }} from '../business-logic'; // Developer must configure path
// import {{ {payload.TypeFullName} }} from '../business-logic/dtos'; // Developer must configure path

// Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}

// const handlerInstance = new {handlerClassName}();

fdk.handle(async (input: any, ctx: any) => {{
    console.log('Function {triggerMethod.MethodName} triggered.');

    try {{
        const payload: {payload.TypeFullName} = input;
        
        // Weave hook and business logic calls here
        // await handlerInstance.{ToCamelCase(triggerMethod.MethodName)}(payload);
        
        return {{ 'message': 'Request processed successfully' }};
    }} catch (error) {{
        console.error('An error occurred:', error);
        ctx.response.statusCode = 500;
        return {{ 'message': 'An error occurred.', 'error': error.message }};
    }}
}});
";
            await File.WriteAllTextAsync(Path.Combine(srcPath, "func.ts"), funcTsContent.Trim());
            _logger.LogDebug($"Generated TypeScript OCI handler file: func.ts");
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
        {
            _logger.LogInfo("Assembling TypeScript OCI test harness project...");
            var testsPath = Path.Combine(testProjectPath, "tests");
            Directory.CreateDirectory(testsPath);

            var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
            var relevantTestFiles = Directory.GetFiles(testSourcePath, $"*{handlerClassNameShort}.test.ts", SearchOption.AllDirectories);
            foreach (var testFile in relevantTestFiles)
            {
                File.Copy(testFile, Path.Combine(testsPath, Path.GetFileName(testFile)), true);
            }

            await GenerateSingleTestHarnessFileAsync(testsPath);
        }

        private async Task GenerateSingleTestHarnessFileAsync(string testPackagePath)
        {
            var harnessFileName = "func.harness.test.ts";
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var businessLogicModuleName = ToCamelCase(handlerClassName);
            var triggerMethod = _blueprint.TriggerMethods.First();

            var harnessContent = $@"
import * as fdk from '@fnproject/fdk';
jest.mock('@fnproject/fdk');

// Mock the business logic module
// jest.mock('../business-logic');
// import {{ {businessLogicModuleName} }} from '../business-logic';

describe('Function Harness', () => {{
    it('should invoke the business logic handler', async () => {{
        // This test will fail here until you implement the mock setups and assertions.
        throw new Error('Test not yet implemented. Please configure mocks and add assertions, then remove this line.');

        /* --- EXAMPLE IMPLEMENTATION ---
        // Arrange
        const {handlerClassName} = require('../../src/func'); // Require after mocking fdk
        const mockMethod = {businessLogicModuleName}.prototype.{ToCamelCase(triggerMethod.MethodName)};
        const mockFdkHandler = (fdk.handle as jest.Mock).mock.calls[0][0];

        const payload = {{ key: 'value' }};
        const mockContext = {{ response: {{}} }};
        
        // Act
        // const result = await mockFdkHandler(payload, mockContext);
        
        // Assert
        // expect(mockMethod).toHaveBeenCalledTimes(1);
        // expect(result.message).toBe('Request processed successfully');
        */
    }});
}});
";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private string ToCamelCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return char.ToLowerInvariant(input[0]) + input.Substring(1);
        }
    }
}