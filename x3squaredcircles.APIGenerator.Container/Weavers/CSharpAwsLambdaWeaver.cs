using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;

namespace x3squaredcircles.DataLink.Container.Weavers
{
    public class CSharpAwsLambdaWeaver : CSharpWeaverBase
    {
        public CSharpAwsLambdaWeaver(IAppLogger logger, ServiceBlueprint blueprint)
            : base(logger, blueprint) { }

        public override async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var requiredPackages = new HashSet<string>
            {
                "Amazon.Lambda.Core",
                "Amazon.Lambda.Serialization.SystemTextJson",
                "Microsoft.Extensions.DependencyInjection",
                "Amazon.Lambda.APIGatewayEvents", // Common for HTTP triggers
                "Amazon.Lambda.SQSEvents",       // Common for SQS triggers
                "Amazon.Lambda.S3Events"         // Common for S3 triggers
            };

            var packageReferences = string.Join("\n", requiredPackages.Select(p =>
                $@"    <PackageReference Include=""{p}"" Version=""{GetPackageVersion(p)}"" />"));

            var logicProjectFilePath = Directory.GetFiles(logicSourcePath, "*.csproj", SearchOption.AllDirectories).FirstOrDefault();
            if (logicProjectFilePath == null) throw new DataLinkException(ExitCode.SourceAnalysisFailed, "LOGIC_CSPROJ_NOT_FOUND", "Could not find a .csproj file in the business logic source path.");
            var relativeLogicPath = Path.GetRelativePath(projectPath, logicProjectFilePath);

            var csprojContent = $@"
<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles>
    <AWSProjectType>Lambda</AWSProjectType>
    <RootNamespace>{_blueprint.ServiceName}</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
{packageReferences}
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include=""{relativeLogicPath}"" />
  </ItemGroup>
</Project>";
            await File.WriteAllTextAsync(Path.Combine(projectPath, $"{_blueprint.ServiceName}.csproj"), csprojContent.Trim());
        }

        public override async Task GenerateStartupFileAsync(string projectPath)
        {
            var allRequiredServices = GetAllRequiredServices();
            var diRegistrations = string.Join(Environment.NewLine, allRequiredServices.Select(cls => $"        services.AddTransient<{cls}>();"));
            var usingStatements = GenerateFileHeader(allRequiredServices);

            var startupContent = $@"
using Microsoft.Extensions.DependencyInjection;
{usingStatements}
using {_blueprint.ServiceName};

namespace {_blueprint.ServiceName}.Generated
{{
    public static class Startup
    {{
        public static IServiceProvider ConfigureServices()
        {{
            var serviceCollection = new ServiceCollection();
            
            // Register developer-defined handler, hook, and dependency classes
{diRegistrations}

            return serviceCollection.BuildServiceProvider();
        }}
    }}
}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "Startup.cs"), startupContent.Trim());
        }

        public override async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var resources = new StringBuilder();
            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                var eventSource = triggerMethod.DslAttributes.First(a => a.Name == "EventSource");
                var (eventType, eventProperties) = ParseUrnForSam(eventSource.Arguments["EventUrn"]);

                // Format: {AssemblyName}::{Namespace}.{ClassName}::{MethodName}
                var handlerPath = $"{_blueprint.ServiceName}::{_blueprint.ServiceName}.Generated.{triggerMethod.MethodName}_Function::HandlerAsync";

                resources.AppendLine($@"  {triggerMethod.MethodName}Function:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Zip
      CodeUri: .
      Handler: {handlerPath}
      Runtime: dotnet8
      Architectures:
        - x86_64
      MemorySize: 512
      Timeout: 30
      Events:
        Trigger:
          Type: {eventType}
          Properties:
{eventProperties}");
            }

            var samTemplateContent = $@"
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  {_blueprint.ServiceName} - Auto-generated by 3SC DataLink from source version {_blueprint.Metadata.SourceVersionTag}

Resources:
{resources.ToString().TrimEnd()}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "template.yaml"), samTemplateContent.Trim());
        }

        public override async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var functionClassName = $"{triggerMethod.MethodName}_Function";
            var handlerVarName = $"_{ToCamelCase(_blueprint.HandlerClassFullName.Split('.').Last())}";

            var diServices = new Dictionary<string, string> { { _blueprint.HandlerClassFullName, handlerVarName } };
            foreach (var service in GetAllRequiredServices().Where(s => s != _blueprint.HandlerClassFullName))
            {
                diServices.TryAdd(service, $"_{ToCamelCase(service.Split('.').Last())}");
            }

            var ctorAssignments = string.Join(Environment.NewLine, diServices.Select(kvp =>
                $"        {kvp.Value} = serviceProvider.GetRequiredService<{kvp.Key}>();"));

            var methodParams = string.Join(", ", triggerMethod.Parameters.Select(p => $"{p.TypeFullName} {p.Name}"));
            var businessLogicCallParams = string.Join(", ", triggerMethod.Parameters.Select(p => p.IsBusinessLogicDependency ? diServices[p.TypeFullName] : p.Name));

            var allUsingTypes = triggerMethod.Parameters.Select(p => p.TypeFullName).Concat(diServices.Keys);

            var functionContent = $@"
using Microsoft.Extensions.DependencyInjection;
{GenerateFileHeader(allUsingTypes)}
using {_blueprint.ServiceName}.Generated;

namespace {_blueprint.ServiceName}.Generated
{{
    public class {functionClassName}
    {{
{string.Join(Environment.NewLine, diServices.Select(kvp => $"        private readonly {kvp.Key} {kvp.Value};"))}

        public {functionClassName}()
        {{
            var serviceProvider = Startup.ConfigureServices();
{ctorAssignments}
        }}

        public async Task<{triggerMethod.ReturnType}> HandlerAsync({methodParams})
        {{
            return await {handlerVarName}.{triggerMethod.MethodName}({businessLogicCallParams});
        }}
    }}
}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, $"{functionClassName}.cs"), functionContent.Trim());
        }

        protected override async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testProjectPath)
        {
            // Placeholder for AWS test harness generation.
            await Task.CompletedTask;
        }

        private (string eventType, string eventProperties) ParseUrnForSam(string urn)
        {
            var parts = urn.Split(':');
            if (parts.Length < 4) return ("Api", "            Path: /invalid-urn\n            Method: get");

            var service = parts[1].ToLowerInvariant();
            var resource = parts[2]; // This is the placeholder e.g. {myS3Bucket}
            var action = string.Join(":", parts.Skip(3));

            switch (service)
            {
                case "s3":
                    return ("S3", $"            Bucket: !Ref {resource.Trim('{', '}')}\n            Events: s3:{action}");
                case "sqs":
                    return ("SQS", $"            Queue: !GetAtt {resource.Trim('{', '}')}.Arn");
                case "apigateway":
                    return ("Api", $"            Path: {resource}\n            Method: {action.ToLowerInvariant()}");
                default:
                    return ("Api", $"            Path: /unsupported-service\n            Method: get");
            }
        }

        private string GetPackageVersion(string packageName)
        {
            return packageName switch
            {
                "Amazon.Lambda.Core" => "2.2.0",
                "Amazon.Lambda.Serialization.SystemTextJson" => "2.4.1",
                "Microsoft.Extensions.DependencyInjection" => "8.0.0",
                "Amazon.Lambda.APIGatewayEvents" => "2.7.0",
                "Amazon.Lambda.SQSEvents" => "2.2.0",
                "Amazon.Lambda.S3Events" => "2.2.0",
                _ => "1.0.0"
            };
        }
    }
}