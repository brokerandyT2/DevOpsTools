using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.MobileAdapter.Generator.Configuration;
using x3squaredcircles.MobileAdapter.Generator.Discovery;
using x3squaredcircles.MobileAdapter.Generator.Models;
using x3squaredcircles.MobileAdapter.Generator.TypeMapping;
namespace x3squaredcircles.MobileAdapter.Generator.Generation
{
    /// <summary>
    /// Generates Swift structures for the iOS platform.
    /// </summary>
    public class IosCodeGenerator : ICodeGenerator
    {
        private readonly ILogger<IosCodeGenerator> _logger;


        public IosCodeGenerator(ILogger<IosCodeGenerator> logger)
        {
            _logger = logger;
        }

        public async Task<List<string>> GenerateAdaptersAsync(
            List<DiscoveredClass> discoveredClasses,
            Dictionary<string, TypeMappingInfo> typeMappings,
            GeneratorConfiguration config)
        {
            var generatedFiles = new List<string>();
            var outputDir = Path.Combine(config.Output.OutputDir, config.Output.IosOutputDir);

            Directory.CreateDirectory(outputDir);

            foreach (var cls in discoveredClasses)
            {
                try
                {
                    var structName = GetTargetClassName(cls);
                    var fileContent = GenerateSwiftStruct(cls, structName, typeMappings, config);
                    var filePath = Path.Combine(outputDir, $"{structName}.swift");
                    await File.WriteAllTextAsync(filePath, fileContent);
                    generatedFiles.Add(filePath);
                    _logger.LogInformation("✓ Generated iOS adapter: {FilePath}", filePath);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to generate Swift adapter for class {ClassName}", cls.Name);
                }
            }

            return generatedFiles;
        }

        private string GetTargetClassName(DiscoveredClass cls)
        {
            if (cls.Metadata.TryGetValue("TargetName", out var targetName) && targetName is string name && !string.IsNullOrWhiteSpace(name))
            {
                _logger.LogDebug("Class '{OriginalName}' is being renamed to '{TargetName}' based on DSL metadata.", cls.Name, name);
                return name;
            }
            return cls.Name;
        }

        private string GenerateSwiftStruct(
            DiscoveredClass cls,
            string targetStructName,
            Dictionary<string, TypeMappingInfo> typeMappings,
            GeneratorConfiguration config)
        {
            var sb = new StringBuilder();

            // Header and Imports
            sb.AppendLine("// Generated by 3SC Mobile Adapter Generator");
            sb.AppendLine("// https://3squaredcircles.com");
            sb.AppendLine();
            sb.AppendLine("import Foundation");
            sb.AppendLine();

            // Struct definition
            // Conforming to Codable for easy JSON serialization.
            sb.AppendLine($"struct {targetStructName}: Codable {{");

            // Properties
            foreach (var prop in cls.Properties)
            {
                var mapping = typeMappings.GetValueOrDefault(prop.Type, new TypeMappingInfo { TargetType = "Any" });
                var propertyType = mapping.TargetType;

                // Handle collections (e.g., List<String> -> [String])
                if (mapping.IsCollection && !string.IsNullOrEmpty(prop.CollectionElementType))
                {
                    var elementMapping = typeMappings.GetValueOrDefault(prop.CollectionElementType, new TypeMappingInfo { TargetType = "Any" });
                    // Swift collections are like [ElementType]
                    propertyType = $"[{elementMapping.TargetType.Trim('?')}]";
                    if (mapping.IsNullable)
                    {
                        propertyType += "?";
                    }
                }

                sb.AppendLine($"    let {prop.Name}: {propertyType}");
            }

            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}