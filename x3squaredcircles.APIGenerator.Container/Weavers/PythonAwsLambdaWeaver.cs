using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a Python AWS Lambda project using SAM.
    /// </summary>
    public class PythonAwsLambdaWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public PythonAwsLambdaWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            // Python projects use requirements.txt for dependencies.
            var requirementsContent = $@"# Auto-generated by 3SC DataLink
# Add any business logic dependencies from your source repository here.
# boto3 is often used in Lambda, but not required by the shim itself.
";
            var filePath = Path.Combine(projectPath, "requirements.txt");
            await File.WriteAllTextAsync(filePath, requirementsContent.Trim());
            _logger.LogDebug($"Generated requirements.txt file: {filePath}");
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            // Python on AWS Lambda uses a simple handler file, not a complex startup class.
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var srcPath = Path.Combine(projectPath, "src");
            Directory.CreateDirectory(srcPath);

            var resources = new StringBuilder();
            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                var trigger = triggerMethod.Triggers.First();
                var handlerPath = $"handler.{triggerMethod.MethodName}";
                var (eventType, eventProperties) = GetSamEvent(trigger);

                resources.AppendLine($@"  {triggerMethod.MethodName}Function:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Zip
      CodeUri: src/
      Handler: {handlerPath}
      Runtime: python3.11
      Architectures:
        - x86_64
      Events:
        Trigger:
          Type: {eventType}
          Properties:
{eventProperties}");
            }

            var samTemplateContent = $@"
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  {_blueprint.ServiceName} - Auto-generated by 3SC DataLink from source version {_blueprint.Metadata.SourceVersionTag}

Resources:
{resources.ToString().TrimEnd()}
";
            var filePath = Path.Combine(projectPath, "template.yaml");
            await File.WriteAllTextAsync(filePath, samTemplateContent.Trim());
            _logger.LogDebug($"Generated template.yaml file: {filePath}");
        }

        private (string, string) GetSamEvent(TriggerDefinition trigger)
        {
            switch (trigger.Type)
            {
                case "Http":
                    var path = trigger.Name.StartsWith("/") ? trigger.Name : "/" + trigger.Name;
                    var method = trigger.Properties.GetValueOrDefault("Method", "post")?.ToLowerInvariant();
                    return ("Api", $"            Path: {path}\n            Method: {method}");
                case "AwsSqsQueue":
                    return ("SQS", $"            Queue: !GetAtt {trigger.Name}Queue.Arn");
                default:
                    return ("Api", "            Path: /default\n            Method: post");
            }
        }

        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var srcPath = Path.Combine(projectPath, "src");
            Directory.CreateDirectory(srcPath);

            // In AWS Lambda Python, it's common to have a single handler.py file
            // that contains all the function entry points.
            var handlerFilePath = Path.Combine(srcPath, "handler.py");
            var handlerContent = new StringBuilder();

            if (!File.Exists(handlerFilePath))
            {
                handlerContent.AppendLine("# -*- coding: utf-8 -*-");
                handlerContent.AppendLine($"# Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}");
                handlerContent.AppendLine($"# Source Version: {_blueprint.Metadata.SourceVersionTag}");
                handlerContent.AppendLine();
                handlerContent.AppendLine("import json");
                handlerContent.AppendLine();
                handlerContent.AppendLine($"# from business_logic import {_blueprint.HandlerClassFullName.Split('.').Last()}");
                handlerContent.AppendLine();
                handlerContent.AppendLine("# In a real application, a single instance of the handler would be created here.");
                handlerContent.AppendLine($"# handler_instance = {_blueprint.HandlerClassFullName.Split('.').Last()}()");
                handlerContent.AppendLine();
            }

            var (payloadExtractionLogic, _) = GetPayloadExtractionLogic(triggerMethod);

            handlerContent.AppendLine($"def {triggerMethod.MethodName}(event, context):");
            handlerContent.AppendLine("    try:");
            handlerContent.AppendLine(payloadExtractionLogic);
            handlerContent.AppendLine($"        print(f\"Processing payload for {triggerMethod.MethodName}: {{payload}}\")");
            handlerContent.AppendLine();
            handlerContent.AppendLine($"        # This is where generated hook logic and the call to business logic would be woven.");
            handlerContent.AppendLine($"        # result = handler_instance.{ToSnakeCase(triggerMethod.MethodName)}(payload)");
            handlerContent.AppendLine();
            handlerContent.AppendLine("        return {");
            handlerContent.AppendLine("            'statusCode': 200,");
            handlerContent.AppendLine("            'body': json.dumps({");
            handlerContent.AppendLine("                'message': 'Request processed successfully.'");
            handlerContent.AppendLine("            })");
            handlerContent.AppendLine("        }");
            handlerContent.AppendLine("    except Exception as e:");
            handlerContent.AppendLine("        print(f\"ERROR in {triggerMethod.MethodName}: {e}\")");
            handlerContent.AppendLine("        return {");
            handlerContent.AppendLine("            'statusCode': 500,");
            handlerContent.AppendLine("            'body': json.dumps({");
            handlerContent.AppendLine("                'message': 'An error occurred.'");
            handlerContent.AppendLine("            })");
            handlerContent.AppendLine("        }");
            handlerContent.AppendLine();

            await File.AppendAllTextAsync(handlerFilePath, handlerContent.ToString());
            _logger.LogDebug($"Appended/Generated Python handler file: {handlerFilePath}");
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
        {
            _logger.LogInfo("Assembling Python test harness project...");
            var testsPath = Path.Combine(testProjectPath, "tests");
            Directory.CreateDirectory(testsPath);

            var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
            var relevantTestFiles = Directory.GetFiles(testSourcePath, $"test_*{ToSnakeCase(handlerClassNameShort)}.py", SearchOption.AllDirectories);
            foreach (var testFile in relevantTestFiles)
            {
                File.Copy(testFile, Path.Combine(testsPath, Path.GetFileName(testFile)), true);
            }

            var testRequirementsContent = @"# Auto-generated by 3SC DataLink
pytest
mock
boto3
";
            await File.WriteAllTextAsync(Path.Combine(testProjectPath, "requirements.txt"), testRequirementsContent.Trim());

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                await GenerateSingleTestHarnessFileAsync(triggerMethod, testsPath);
            }
        }

        private async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var harnessFileName = $"test_{triggerMethod.MethodName}_harness.py";
            var businessLogicModuleName = ToSnakeCase(_blueprint.HandlerClassFullName.Split('.').Last());

            var harnessContent = $@"
# Auto-generated by 3SC DataLink. This test skeleton is designed to fail by default.
import json
import pytest
from unittest import mock

# It is assumed that the 'src' directory containing handler.py is on the python path
import handler

class Test{triggerMethod.MethodName}Harness:

    @mock.patch('handler.{businessLogicModuleName}') # Mock the business logic module
    def test_{ToSnakeCase(triggerMethod.MethodName)}_invokes_business_logic(self, mock_business_logic_module):
        """"""
        This test verifies that the generated shim correctly invokes the business logic.
        """"""
        # This test will fail here until you implement the mock setups and assertions.
        pytest.fail(""Test not yet implemented. Please configure mocks and add assertions, then remove this line."")

        # --- EXAMPLE IMPLEMENTATION ---
        # # Arrange
        # mock_handler_instance = mock_business_logic_module.{_blueprint.HandlerClassFullName.Split('.').Last()}.return_value
        # 
        # event = {{
        #     'body': json.dumps({{'key': 'value'}})
        # }}
        # context = None
        #
        # # Act
        # result = handler.{triggerMethod.MethodName}(event, context)
        #
        # # Assert
        # assert result['statusCode'] == 200
        # mock_handler_instance.{ToSnakeCase(triggerMethod.MethodName)}.assert_called_once()
";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private (string payloadLogic, string responseLogic) GetPayloadExtractionLogic(TriggerMethod triggerMethod)
        {
            var trigger = triggerMethod.Triggers.First();
            switch (trigger.Type)
            {
                case "Http":
                    return ("        payload = json.loads(event.get('body', '{}'))", "");
                case "AwsSqsQueue":
                    return ("        for record in event.get('Records', []):\n            payload = json.loads(record.get('body', '{}'))", "");
                default:
                    return ("        payload = event", "");
            }
        }

        private string ToSnakeCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return string.Concat(input.Select((x, i) => i > 0 && char.IsUpper(x) ? "_" + x.ToString() : x.ToString())).ToLower();
        }
    }
}