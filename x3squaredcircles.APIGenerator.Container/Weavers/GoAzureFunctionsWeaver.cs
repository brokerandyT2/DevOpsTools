using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a Go Azure Functions project.
    /// </summary>
    public class GoAzureFunctionsWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public GoAzureFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            // For Go, the primary project file is go.mod.
            var moduleName = _blueprint.ServiceName.ToLowerInvariant();
            var goModContent = $@"
module {moduleName}

go 1.21

require (
    github.com/Azure/azure-functions-go-worker v1.3.0
)
";
            var filePath = Path.Combine(projectPath, "go.mod");
            await File.WriteAllTextAsync(filePath, goModContent.Trim());
            _logger.LogDebug($"Generated go.mod file: {filePath}");
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            // Go on Azure Functions uses a simple main.go file, which is the startup and function handler.
            _logger.LogDebug("Go Azure Functions startup logic will be generated in the handler file.");
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var hostJsonContent = @"{
  ""version"": ""2.0"",
  ""logging"": {
    ""logLevel"": {
      ""default"": ""Information""
    }
  },
  ""extensionBundle"": {
    ""id"": ""Microsoft.Azure.Functions.ExtensionBundle"",
    ""version"": ""[4.*, 5.0.0)""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "host.json"), hostJsonContent.Trim());

            var settingsJsonContent = @"{
  ""IsEncrypted"": false,
  ""Values"": {
    ""AzureWebJobsStorage"": ""UseDevelopmentStorage=true"",
    ""FUNCTIONS_WORKER_RUNTIME"": ""custom"",
    ""FUNCTIONS_WORKER_EXECUTABLE_PATH"": ""./handler""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "local.settings.json"), settingsJsonContent.Trim());
            _logger.LogDebug($"Generated host.json and local.settings.json at: {projectPath}");
        }

        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            // For Go on Azure Functions, each function is a separate directory containing a function.json
            var functionName = triggerMethod.MethodName;
            var functionPath = Path.Combine(projectPath, functionName);
            Directory.CreateDirectory(functionPath);

            var payload = triggerMethod.Parameters.First(p => p.IsPayload);
            var (bindingType, bindingDirection, bindingName, bindingProperties) = GetBindingDetails(triggerMethod.Triggers.First());

            // Generate function.json
            var functionJsonContent = $@"
{{
  ""scriptFile"": ""../handler"",
  ""bindings"": [
    {{
      ""authLevel"": ""function"",
      ""type"": ""{bindingType}"",
      ""direction"": ""{bindingDirection}"",
      ""name"": ""{bindingName}""
      {bindingProperties}
    }},
    {{
      ""type"": ""http"",
      ""direction"": ""out"",
      ""name"": ""$return""
    }}
  ]
}}
";
            await File.WriteAllTextAsync(Path.Combine(functionPath, "function.json"), functionJsonContent.Trim());

            // Generate or append to the main handler.go file
            var handlerFilePath = Path.Combine(projectPath, "handler.go");
            await GenerateGoHandlerFileAsync(handlerFilePath, triggerMethod, payload);
        }

        private async Task GenerateGoHandlerFileAsync(string filePath, TriggerMethod triggerMethod, ParameterDefinition payload)
        {
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last(); // Assuming Go struct name matches class name

            var handlerContent = new StringBuilder();

            // Create the file with package and imports only if it doesn't exist
            if (!File.Exists(filePath))
            {
                handlerContent.AppendLine($"// Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}");
                handlerContent.AppendLine($"// Source Version: {_blueprint.Metadata.SourceVersionTag}");
                handlerContent.AppendLine();
                handlerContent.AppendLine("package main");
                handlerContent.AppendLine();
                handlerContent.AppendLine("import (");
                handlerContent.AppendLine("    \"context\"");
                handlerContent.AppendLine("    \"encoding/json\"");
                handlerContent.AppendLine("    \"log\"");
                handlerContent.AppendLine("    \"net/http\"");
                handlerContent.AppendLine();
                handlerContent.AppendLine("    \"github.com/Azure/azure-functions-go-worker/dispatcher\"");
                handlerContent.AppendLine("    \"github.com/Azure/azure-functions-go-worker/rpc\"");
                handlerContent.AppendLine(")");
                handlerContent.AppendLine();
                handlerContent.AppendLine("func main() {");
                handlerContent.AppendLine("    dispatcher.Initialize(nil)");
                handlerContent.AppendLine("}");
            }

            handlerContent.AppendLine();
            handlerContent.AppendLine($"// {triggerMethod.MethodName} is the entry point for the '{triggerMethod.MethodName}' function.");
            handlerContent.AppendLine($"func {triggerMethod.MethodName}(ctx context.Context, req *rpc.HttpRequest) *rpc.TypedData {{");
            handlerContent.AppendLine($"    log.Printf(\"Go HTTP trigger for function {triggerMethod.MethodName} processed a request.\")");
            handlerContent.AppendLine();
            handlerContent.AppendLine($"    var payload {payload.TypeFullName} // Assuming DTO is in the same package");
            handlerContent.AppendLine("    if err := json.Unmarshal([]byte(req.Body.GetString()), &payload); err != nil {");
            handlerContent.AppendLine("        return &rpc.TypedData{ String: \"Invalid request body\" }");
            handlerContent.AppendLine("    }");
            handlerContent.AppendLine();
            handlerContent.AppendLine("    // In a real application, a DI framework would provide the handler instance.");
            handlerContent.AppendLine($"    // handler := businesslogic.New{handlerClassName}()");
            handlerContent.AppendLine("    // err := handler.{triggerMethod.MethodName}(payload)");
            handlerContent.AppendLine("    // if err != nil { ... }");
            handlerContent.AppendLine();
            handlerContent.AppendLine("    return &rpc.TypedData{ String: \"Request processed successfully.\" }");
            handlerContent.AppendLine("}");

            await File.AppendAllTextAsync(filePath, handlerContent.ToString());
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
        {
            _logger.LogInfo("Assembling Go test harness project...");
            var testsPath = Path.Combine(testProjectPath, "tests");
            Directory.CreateDirectory(testsPath);

            var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
            var relevantTestFiles = Directory.GetFiles(testSourcePath, $"*{ToSnakeCase(handlerClassNameShort)}_test.go", SearchOption.AllDirectories);
            foreach (var testFile in relevantTestFiles)
            {
                File.Copy(testFile, Path.Combine(testsPath, Path.GetFileName(testFile)), true);
            }

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                await GenerateSingleTestHarnessFileAsync(triggerMethod, testsPath);
            }
        }

        private async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var harnessFileName = $"{ToSnakeCase(triggerMethod.MethodName)}_harness_test.go";

            var harnessContent = $@"
package main_test

import (
    ""context""
    ""testing""
    ""github.com/stretchr/testify/assert""
    // ""{_blueprint.ServiceName}/mocks"" // Assuming mock package
    // main ""{_blueprint.ServiceName}"" // Assuming main package
)

// Auto-generated by 3SC DataLink. This test skeleton is designed to fail by default.
func Test{triggerMethod.MethodName}_Harness(t *testing.T) {{
    t.Fatal(""Test not yet implemented. Please configure mock setups and add assertions."")

    /* --- EXAMPLE IMPLEMENTATION ---
    // Arrange
    // mockCtrl := gomock.NewController(t)
    // defer mockCtrl.Finish()
    // mockHandler := mocks.NewMockMyHandler(mockCtrl)

    // // This requires a way to inject the mock into the handler, typically via an interface
    // main.SetHandler(mockHandler)

    // mockHandler.EXPECT().{triggerMethod.MethodName}(gomock.Any()).Return(nil)

    // req := &rpc.HttpRequest{{
    //     Body: &rpc.TypedData{{ String: `{{""key"":""value""}}` }},
    // }}

    // // Act
    // result := main.{triggerMethod.MethodName}(context.Background(), req)

    // // Assert
    // assert.NotNil(t, result)
    // assert.Equal(t, ""Request processed successfully"", result.GetString_())
    */
}}";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private (string Type, string Direction, string Name, string Properties) GetBindingDetails(TriggerDefinition trigger)
        {
            switch (trigger.Type)
            {
                case "Http":
                    var route = trigger.Name.TrimStart('/');
                    var methods = trigger.Properties.GetValueOrDefault("Method", "post")?.ToLowerInvariant();
                    var properties = $@",
      ""route"": ""{route}"",
      ""methods"": [ ""{methods}"" ]";
                    return ("httpTrigger", "in", "req", properties);
                default:
                    throw new NotSupportedException($"Trigger type '{trigger.Type}' is not supported for Go Azure Functions generation.");
            }
        }

        private string ToSnakeCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return string.Concat(input.Select((x, i) => i > 0 && char.IsUpper(x) ? "_" + x.ToString() : x.ToString())).ToLower();
        }
    }
}