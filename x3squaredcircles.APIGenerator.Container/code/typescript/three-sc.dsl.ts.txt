// 3SC Conduit: TypeScript Decorator DSL
// Version: 1.0.0
// Auto-generated by 3SC DataLink. Do not modify.
// Requires "experimentalDecorators": true in tsconfig.json and the 'reflect-metadata' package.
import 'reflect-metadata';

export enum TriggerType { Http = "Http", AzureServiceBusQueue = "AzureServiceBusQueue", AwsSqsQueue = "AwsSqsQueue", KafkaTopic = "KafkaTopic", Cron = "Cron", Scaffold = "Scaffold" }
export enum LoggingAction { OnInbound = "OnInbound", OnOutbound = "OnOutbound", OnError = "OnError" }
type Constructor<T = any> = new (...args: any[]) => T;

export function DataConsumer(options: { serviceName?: string }): ClassDecorator {
    return (target) => { Reflect.defineMetadata('service:name', options.serviceName || target.name, target); };
}

export function Trigger(options: { type: TriggerType; name?: string; method?: string }): MethodDecorator {
    return (target, propertyKey) => {
        const triggers = Reflect.getMetadata('triggers', target.constructor, propertyKey) || [];
        triggers.push(options);
        Reflect.defineMetadata('triggers', triggers, target.constructor, propertyKey);
    };
}

export function Requires(options: { handler: Constructor; method: string }): MethodDecorator {
    return (target, propertyKey) => {
        const requires = Reflect.getMetadata('requires', target.constructor, propertyKey) || [];
        requires.push({ handler: options.handler.name, method: options.method });
        Reflect.defineMetadata('requires', requires, target.constructor, propertyKey);
    };
}

export function RequiresLogger(options: { handler: Constructor; action: LoggingAction }): MethodDecorator {
    return (target, propertyKey) => {
        const loggers = Reflect.getMetadata('requires:loggers', target.constructor, propertyKey) || [];
        loggers.push({ handler: options.handler.name, action: options.action });
        Reflect.defineMetadata('requires:loggers', loggers, target.constructor, propertyKey);
    };
}

export function RequiresResultsLogger(options: { handler: Constructor; method: string; variable: string }): MethodDecorator {
    return (target, propertyKey) => {
        const resultsLoggers = Reflect.getMetadata('requires:resultsloggers', target.constructor, propertyKey) || [];
        resultsLoggers.push({ handler: options.handler.name, method: options.method, variable: options.variable });
        Reflect.defineMetadata('requires:resultsloggers', resultsLoggers, target.constructor, propertyKey);
    };
}

export function UseTemplate(options: { templatePath: string }): MethodDecorator {
    return (target, propertyKey) => {
        Reflect.defineMetadata('template:path', options.templatePath, target.constructor, propertyKey);
    };
}