using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;

namespace x3squaredcircles.DataLink.Container.Weavers
{
    public class PythonAzureFunctionsWeaver : ScriptingWeaverBase
    {
        public PythonAzureFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
            : base(logger, blueprint) { }

        protected override string GetDeveloperTestFilePattern(string handlerClassNameShort) => $"test_*{ToSnakeCase(handlerClassNameShort)}.py";
        protected override string GetHandlerFileName() => "function_app.py";

        public override async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var devRequirements = string.Empty;
            var devReqFile = Directory.GetFiles(logicSourcePath, "requirements.txt", SearchOption.AllDirectories).FirstOrDefault();
            if (devReqFile != null)
            {
                devRequirements = await File.ReadAllTextAsync(devReqFile);
            }

            var requirementsContent = $@"# Auto-generated by 3SC DataLink
azure-functions
{devRequirements}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "requirements.txt"), requirementsContent.Trim());

            var destLogicPath = Path.Combine(projectPath, "business_logic");
            CopyDirectory(logicSourcePath, destLogicPath);
        }

        public override Task GenerateStartupFileAsync(string projectPath)
        {
            // Python v2 model uses function_app.py as the entry point.
            return Task.CompletedTask;
        }

        public override async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var hostJsonContent = @"{""version"": ""2.0"", ""logging"": {""applicationInsights"": {""samplingSettings"": {""isEnabled"": true, ""excludedTypes"": ""Request""}}}, ""extensionBundle"": {""id"": ""Microsoft.Azure.Functions.ExtensionBundle"", ""version"": ""[4.*, 5.0.0)""}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "host.json"), hostJsonContent.Trim());

            var settingsJsonContent = @"{""IsEncrypted"": false, ""Values"": {""AzureWebJobsStorage"": ""UseDevelopmentStorage=true"", ""FUNCTIONS_WORKER_RUNTIME"": ""python""}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "local.settings.json"), settingsJsonContent.Trim());
        }

        public override async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var functionAppFilePath = Path.Combine(projectPath, GetHandlerFileName());
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerModuleName = ToSnakeCase(handlerClassName);
            var handlerVarName = ToSnakeCase(handlerClassName);

            var sb = new StringBuilder();
            if (!File.Exists(functionAppFilePath))
            {
                // Create the file shell if it's the first time.
                sb.AppendLine("# -*- coding: utf-8 -*-");
                sb.AppendLine("# Auto-generated by 3SC DataLink");
                sb.AppendLine("import azure.functions as func");
                sb.AppendLine("import logging");
                sb.AppendLine("import json");
                sb.AppendLine();
                sb.AppendLine($"from business_logic.{handlerModuleName} import {handlerClassName}");
                sb.AppendLine();
                sb.AppendLine("app = func.FunctionApp()");
                sb.AppendLine($"handler_instance = {handlerClassName}()");
                sb.AppendLine();
            }

            var eventSource = triggerMethod.DslAttributes.First(a => a.Name == "EventSource");
            var (decorator, triggerVariable) = ParseUrnForAzureDecorator(eventSource.Arguments["EventUrn"], triggerMethod.MethodName);

            sb.AppendLine($"@{decorator}");
            sb.AppendLine($"def {triggerMethod.MethodName}({triggerVariable}):");
            sb.AppendLine($"    logging.info('Python trigger function `{triggerMethod.MethodName}` processed a request.')");
            sb.AppendLine("    try:");
            sb.AppendLine("        # Simplified payload extraction logic");
            sb.AppendLine($"        payload = json.loads(req.get_body()) if hasattr(req, 'get_body') else req");
            sb.AppendLine($"        result = handler_instance.{ToSnakeCase(triggerMethod.MethodName)}(**payload)");
            sb.AppendLine("        return func.HttpResponse(json.dumps(result or {'message': 'Success'}), status_code=200, mimetype='application/json')");
            sb.AppendLine("    except Exception as e:");
            sb.AppendLine("        logging.error(f\"An error occurred: {e}\")");
            sb.AppendLine("        return func.HttpResponse(\"An error occurred during execution.\", status_code=500)");
            sb.AppendLine();

            await File.AppendAllTextAsync(functionAppFilePath, sb.ToString());
        }

        protected override async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var harnessFileName = $"test_{triggerMethod.MethodName}_harness.py";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), "# TODO: Implement Python Azure test harness");
        }

        private (string decorator, string triggerVariable) ParseUrnForAzureDecorator(string urn, string functionName)
        {
            var parts = urn.Split(':');
            if (parts.Length < 4) return ("app.route(route=\"invalid-urn\")", "req: func.HttpRequest");

            var service = parts[1].ToLowerInvariant();
            var resource = parts[2];
            var action = string.Join(":", parts.Skip(3));

            switch (service)
            {
                case "apigateway":
                    var method = action.ToUpperInvariant();
                    return ($"app.route(route=\"{resource.TrimStart('/')}\", methods=[func.HttpMethod.{method}], auth_level=func.AuthLevel.FUNCTION)", "req: func.HttpRequest");
                case "servicebus":
                    return ($"app.service_bus_queue_trigger(arg_name=\"msg\", queue_name=\"{resource}\", connection=\"ServiceBusConnection\")", "msg: func.ServiceBusMessage");
                default:
                    return ($"app.route(route=\"unsupported-service\")", "req: func.HttpRequest");
            }
        }

        private void CopyDirectory(string sourceDir, string destinationDir)
        {
            var dir = new DirectoryInfo(sourceDir);
            if (!dir.Exists) return;

            Directory.CreateDirectory(destinationDir);
            foreach (FileInfo file in dir.GetFiles())
            {
                file.CopyTo(Path.Combine(destinationDir, file.Name), true);
            }
            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                if (subDir.Name != "tests" && subDir.Name != ".git" && !subDir.Name.Contains("__pycache__"))
                {
                    CopyDirectory(subDir.FullName, Path.Combine(destinationDir, subDir.Name));
                }
            }
        }
    }
}