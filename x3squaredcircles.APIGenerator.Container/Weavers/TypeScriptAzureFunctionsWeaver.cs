using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using static System.Net.Mime.MediaTypeNames;

namespace x3squaredcircles.DataLink.Container.Weavers
{
    public class TypeScriptAzureFunctionsWeaver : ScriptingWeaverBase
    {
        public TypeScriptAzureFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
            : base(logger, blueprint) { }

        protected override string GetDeveloperTestFilePattern(string handlerClassNameShort) => $"*{handlerClassNameShort}.test.ts";
        protected override string GetHandlerFileName() => "index.ts";

        // In TypeScriptAzureFunctionsWeaver.cs

        // In TypeScriptAzureFunctionsWeaver.cs



        public override Task GenerateStartupFileAsync(string projectPath)
        {
            return Task.CompletedTask;
        }
        // In TypeScriptAzureFunctionsWeaver.cs

        public override async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var devDependencies = new StringBuilder();
            devDependencies.AppendLine(@"    ""@azure/functions"": ""^4.0.0"",");
            devDependencies.AppendLine(@"    ""@types/node"": ""^18.x"",");
            devDependencies.AppendLine(@"    ""typescript"": ""^4.0.0"",");
            devDependencies.AppendLine(@"    ""@types/jest"": ""^29.5.12"",");
            devDependencies.AppendLine(@"    ""jest"": ""^29.7.0"",");
            devDependencies.AppendLine(@"    ""ts-jest"": ""^29.1.2""");

            //
            // THE FIX IS HERE:
            // We build the entire package.json content using a StringBuilder to ensure
            // correct formatting and avoid the complex, error-prone interpolated string.
            //
            var packageJsonBuilder = new StringBuilder();
            packageJsonBuilder.AppendLine("{");
            packageJsonBuilder.AppendLine($@"  ""name"": ""{_blueprint.ServiceName.ToLowerInvariant()}"",");
            packageJsonBuilder.AppendLine(@"  ""version"": ""1.0.0"",");
            packageJsonBuilder.AppendLine(@"  ""description"": ""Auto-generated by 3SC DataLink"",");
            packageJsonBuilder.AppendLine(@"  ""scripts"": {");
            packageJsonBuilder.AppendLine(@"    ""build"": ""tsc"",");
            packageJsonBuilder.AppendLine(@"    ""watch"": ""tsc -w"",");
            packageJsonBuilder.AppendLine(@"    ""prestart"": ""npm run build"",");
            packageJsonBuilder.AppendLine(@"    ""start"": ""func start"",");
            packageJsonBuilder.AppendLine(@"    ""test"": ""jest""");
            packageJsonBuilder.AppendLine(@"  },");
            packageJsonBuilder.AppendLine(@"  ""dependencies"": {},");
            packageJsonBuilder.AppendLine(@"  ""devDependencies"": {");
            // Append the dev dependencies, then trim the final comma and newline from that block.
            packageJsonBuilder.Append(devDependencies.ToString().TrimEnd(',', '\r', '\n', ' '));
            packageJsonBuilder.AppendLine();
            packageJsonBuilder.AppendLine("  }");
            packageJsonBuilder.AppendLine("}");

            await File.WriteAllTextAsync(Path.Combine(projectPath, "package.json"), packageJsonBuilder.ToString());

            var tsConfigContent = @"{""compilerOptions"": {""module"": ""commonjs"", ""target"": ""es6"", ""outDir"": ""dist"", ""rootDir"": ""."", ""sourceMap"": true, ""strict"": true}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "tsconfig.json"), tsConfigContent.Trim());

            var jestConfigContent = @"module.exports = { preset: 'ts-jest', testEnvironment: 'node' };";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "jest.config.js"), jestConfigContent.Trim());

            var destLogicPath = Path.Combine(projectPath, "business_logic");
            CopyDirectory(logicSourcePath, destLogicPath);
        }
        public override async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var hostJsonContent = @"{""version"": ""2.0"", ""logging"": {""applicationInsights"": {""samplingSettings"": {""isEnabled"": true, ""excludedTypes"": ""Request""}}}, ""extensionBundle"": {""id"": ""Microsoft.Azure.Functions.ExtensionBundle"", ""version"": ""[4.*, 5.0.0)""}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "host.json"), hostJsonContent.Trim());

            var settingsJsonContent = @"{""IsEncrypted"": false, ""Values"": {""AzureWebJobsStorage"": ""UseDevelopmentStorage=true"", ""FUNCTIONS_WORKER_RUNTIME"": ""node""}}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "local.settings.json"), settingsJsonContent.Trim());

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                var functionPath = Path.Combine(projectPath, triggerMethod.MethodName);
                Directory.CreateDirectory(functionPath);

                var eventSource = triggerMethod.DslAttributes.First(a => a.Name == "EventSource");
                var bindings = ParseUrnForFunctionJson(eventSource.Arguments["EventUrn"]);

                var functionJson = JsonSerializer.Serialize(new
                {
                    scriptFile = $"../dist/{triggerMethod.MethodName}/index.js",
                    bindings
                }, new JsonSerializerOptions { WriteIndented = true });
                await File.WriteAllTextAsync(Path.Combine(functionPath, "function.json"), functionJson);
            }
        }

        public override async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var functionPath = Path.Combine(projectPath, triggerMethod.MethodName);
            Directory.CreateDirectory(functionPath);
            var handlerFilePath = Path.Combine(functionPath, GetHandlerFileName());

            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerVarName = ToCamelCase(handlerClassName);

            var payloadParam = triggerMethod.Parameters.FirstOrDefault(p => !p.IsBusinessLogicDependency);
            if (payloadParam == null) throw new DataLinkException(ExitCode.CodeGenerationFailed, "TS_PAYLOAD_NOT_FOUND", $"Method '{triggerMethod.MethodName}' requires a payload parameter.");

            var handlerContent = $@"
import {{ AzureFunction, Context, HttpRequest }} from ""@azure/functions""
import {{ {handlerClassName} }} from '../business_logic'; // This path may need adjustment

const handlerInstance = new {handlerClassName}();

const {ToCamelCase(triggerMethod.MethodName)}: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {{
    context.log('HTTP trigger function processed a request.');
    
    try {{
        const payload = req.body;
        const result = await handlerInstance.{ToCamelCase(triggerMethod.MethodName)}(payload);
        context.res = {{
            status: 200,
            body: result || {{ message: 'Success' }},
            headers: {{ 'Content-Type': 'application/json' }}
        }};
    }} catch (error) {{
        context.log.error('An error occurred:', error);
        context.res = {{
            status: 500,
            body: ""An error occurred during execution.""
        }};
    }}
}};

export default {ToCamelCase(triggerMethod.MethodName)};
";
            await File.WriteAllTextAsync(handlerFilePath, handlerContent.Trim());
        }

        protected override async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var harnessFileName = $"{triggerMethod.MethodName}.harness.test.ts";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), "// TODO: Implement TypeScript Azure test harness");
        }

        private List<object> ParseUrnForFunctionJson(string urn)
        {
            var parts = urn.Split(':');
            var bindings = new List<object>();
            if (parts.Length < 4) return bindings;

            var service = parts[1].ToLowerInvariant();
            var resource = parts[2];
            var action = string.Join(":", parts.Skip(3));

            switch (service)
            {
                case "apigateway":
                    bindings.Add(new
                    {
                        authLevel = "anonymous",
                        type = "httpTrigger",
                        direction = "in",
                        name = "req",
                        methods = new[] { action.ToLowerInvariant() },
                        route = resource
                    });
                    bindings.Add(new
                    {
                        type = "http",
                        direction = "out",
                        name = "res"
                    });
                    break;
                case "servicebus":
                    bindings.Add(new
                    {
                        type = "serviceBusTrigger",
                        direction = "in",
                        name = "message",
                        queueName = resource,
                        connection = "ServiceBusConnection"
                    });
                    break;
            }
            return bindings;
        }

        private void CopyDirectory(string sourceDir, string destinationDir)
        {
            var dir = new DirectoryInfo(sourceDir);
            if (!dir.Exists) return;

            Directory.CreateDirectory(destinationDir);
            foreach (FileInfo file in dir.GetFiles())
            {
                file.CopyTo(Path.Combine(destinationDir, file.Name), true);
            }
            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                if (subDir.Name != "tests" && subDir.Name != ".git" && subDir.Name != "node_modules" && subDir.Name != "dist")
                {
                    CopyDirectory(subDir.FullName, Path.Combine(destinationDir, subDir.Name));
                }
            }
        }
    }
}