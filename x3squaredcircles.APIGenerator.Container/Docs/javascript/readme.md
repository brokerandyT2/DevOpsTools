# 3SC Conduit: JavaScript Developer Guide

This guide provides JavaScript-specific examples for using the `3SC Conduit` JSDoc tags to define and generate event-driven services.

JavaScript does not have native decorators or annotations. Instead, Conduit parses structured JSDoc comment blocks placed directly above your classes and methods. To get started, download the `datalink_helpers.js` file from the running Conduit container at `/code/javascript`.

## 1. Defining a Service with `@DataConsumer`

Mark a class that will contain your business logic with the `@DataConsumer` JSDoc tag. This is the top-level entry point for the tool's analyzer.

```javascript
/**
 * @DataConsumer(serviceName = "order-processing-service")
 */
class OrderProcessor {
    // ... your trigger methods go here
}
module.exports = { OrderProcessor };
```

## 2. Defining a Trigger with `@Trigger`

Place a `@Trigger` JSDoc tag directly above a method of your DataConsumer class to expose it as a service entry point. The first parameter of the method is always the data contract.

```javascript
const { TriggerType } = require('./datalink_helpers');

/**
 * @DataConsumer
 */
class OrderProcessor {
    /**
     * @Trigger(type="AwsSqsQueue", name="new-orders")
     * @param {OrderEvent} order
     * @param {DbConnection} db
     */
    async handleNewOrder(order, db) {
        // Your business logic here...
    }

    /**
     * @Trigger(type="Http", name="orders/manual-entry")
     * @param {OrderEvent} order
     * @param {Logger} logger
     */
    async handleManualOrder(order, logger) {
        logger.info("Manual order received.");
        // ...
    }
}
```

## 3. Requiring a Pre-Processing Gate with `@Requires`

Use `@Requires` to enforce a gatekeeper, like an authentication check, before your main logic is executed. The handler should be a reference to a function that returns a boolean.

```javascript
// In your shared hooks library (e.g., hooks/auth.js)
function validateRequest(request) {
    // ... check JWT ...
    return true;
}

// In your business logic
const { validateRequest } = require('./hooks/auth');

/**
 * @DataConsumer
 */
class AdminService {
    /**
     * @Trigger(type="Http", name="admin/run-job")
     * @Requires(handler="validateRequest")
     * @param {AdminJobPayload} payload
     */
    runAdminJob(payload) {
        // This code only runs if validateRequest returns true.
    }
}
```

**Note**: The handler is specified as a string matching the imported function name.

## 4. Requiring Logging with `@RequiresLogger`

Use `@RequiresLogger` to declaratively add observability. The tool will automatically wrap your trigger method in a try/catch block and call your specified logger function.

```javascript
// In your shared logging library (e.g., loggers/splunk.js)
function logEvent(payloadOrError) {
    // Logic to send data to Splunk
}

// In your business logic
const { logEvent } = require('./loggers/splunk');
const { LoggingAction } = require('./datalink_helpers');

/**
 * @DataConsumer
 */
class OrderProcessor {
    /**
     * @Trigger(type="Http", name="orders")
     * @RequiresLogger(handler="logEvent", action="OnInbound")
     * @RequiresLogger(handler="logEvent", action="OnError")
     * @param {OrderEvent} order
     */
    handleNewOrder(order) {
        // ... your logic ...
    }
}
```

## 5. Trace Logging with `@RequiresResultsLogger`

Use `@RequiresResultsLogger` to get deep insight into your method's execution by logging the state of local variables.

```javascript
/**
 * @DataConsumer
 */
class ComplexWorkflow {
    /**
     * @Trigger(type="Http", name="workflows/start")
     * @RequiresResultsLogger(handler="logEvent", variable="validated")
     * @RequiresResultsLogger(handler="logEvent", variable="enriched")
     * @param {InitialPayload} payload
     */
    startWorkflow(payload) {
        const validated = this.validate(payload);
        // The tool will inject a call to logEvent({ validated }) here.

        const enriched = this.enrich(validated);
        // The tool will inject a call to logEvent({ enriched }) here.

        this.save(enriched);
    }

    validate(payload) {
        // Validation logic
        return payload;
    }

    enrich(validatedPayload) {
        // Enrichment logic
        return validatedPayload;
    }

    save(enrichedPayload) {
        // Save logic
    }
}
```

## Helper File: `datalink_helpers.js`

The following helper file provides enums and constants for use with the JSDoc directives:

```javascript
// 3SC Conduit: JavaScript Helper File
// Version: 1.0.0
// Auto-generated by 3SC DataLink. Do not modify.
//
// This file provides helper enums for use in JSDoc comment directives.

/**
 * Defines the event source that will invoke a method.
 * @readonly
 * @enum {string}
 */
const TriggerType = {
    Http: "Http",
    AzureServiceBusQueue: "AzureServiceBusQueue",
    AwsSqsQueue: "AwsSqsQueue",
    KafkaTopic: "KafkaTopic",
    Cron: "Cron",
    Scaffold: "Scaffold"
};

/**
 * Defines the logging action to be performed by a @RequiresLogger hook.
 * @readonly
 * @enum {string}
 */
const LoggingAction = {
    /**
     * Logs the inbound payload/DTO at the beginning of the execution.
     */
    OnInbound: "OnInbound",
    /**
     * Logs the successful return value of the method at the end of execution.
     */
    OnOutbound: "OnOutbound",
    /**
     * Logs the exception if the method fails.
     */
    OnError: "OnError"
};

module.exports = {
    TriggerType,
    LoggingAction
};
```