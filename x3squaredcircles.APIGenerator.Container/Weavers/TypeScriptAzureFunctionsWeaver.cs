using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a TypeScript Azure Functions project.
    /// </summary>
    public class TypeScriptAzureFunctionsWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public TypeScriptAzureFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var devDependencies = new StringBuilder();
            devDependencies.AppendLine(@"    ""@azure/functions"": ""^4.0.0"",");
            devDependencies.AppendLine(@"    ""@types/node"": ""^18.x"",");
            devDependencies.AppendLine(@"    ""typescript"": ""^4.0.0"",");
            devDependencies.AppendLine(@"    ""@types/jest"": ""^29.5.12"",");
            devDependencies.AppendLine(@"    ""jest"": ""^29.7.0"",");
            devDependencies.AppendLine(@"    ""ts-jest"": ""^29.1.2""");

            var packageJsonContent = $@"
{{
  ""name"": ""{_blueprint.ServiceName.ToLowerInvariant()}"",
  ""version"": ""1.0.0"",
  ""description"": ""Auto-generated by 3SC DataLink"",
  ""scripts"": {{
    ""build"": ""tsc"",
    ""watch"": ""tsc -w"",
    ""prestart"": ""npm run build"",
    ""start"": ""func start"",
    ""test"": ""jest""
  }},
  ""dependencies"": {{ }},
  ""devDependencies"": {{
{devDependencies.ToString().TrimEnd(',')}
  }}
}}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "package.json"), packageJsonContent.Trim());

            var tsConfigContent = @"{
  ""compilerOptions"": {
    ""module"": ""commonjs"",
    ""target"": ""es6"",
    ""outDir"": ""dist"",
    ""rootDir"": ""src"",
    ""sourceMap"": true,
    ""strict"": true
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "tsconfig.json"), tsConfigContent.Trim());

            var jestConfigContent = @"module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts']
};";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "jest.config.js"), jestConfigContent.Trim());

            var gitignoreContent = @"
# Dependencies
/node_modules
/dist

# Local
local.settings.json

# IDE
.vscode
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, ".gitignore"), gitignoreContent.Trim());
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            // TypeScript/Node.js on Azure Functions does not use a single startup file like Program.cs.
            // Configuration and triggers are defined in function.json and the handler files.
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var hostJsonContent = @"{
  ""version"": ""2.0"",
  ""logging"": {
    ""applicationInsights"": {
      ""samplingSettings"": {
        ""isEnabled"": true,
        ""excludedTypes"": ""Request""
      }
    }
  },
  ""extensionBundle"": {
    ""id"": ""Microsoft.Azure.Functions.ExtensionBundle"",
    ""version"": ""[4.*, 5.0.0)""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "host.json"), hostJsonContent.Trim());

            var settingsJsonContent = @"{
  ""IsEncrypted"": false,
  ""Values"": {
    ""AzureWebJobsStorage"": ""UseDevelopmentStorage=true"",
    ""FUNCTIONS_WORKER_RUNTIME"": ""node""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "local.settings.json"), settingsJsonContent.Trim());
            _logger.LogDebug($"Generated host.json and local.settings.json at: {projectPath}");
        }
        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var functionName = triggerMethod.MethodName;
            var functionPath = Path.Combine(projectPath, functionName);
            Directory.CreateDirectory(functionPath);

            var payload = triggerMethod.Parameters.First(p => p.IsPayload);
            var (bindingType, bindingDirection, bindingName, bindingProperties) = GetBindingDetails(triggerMethod.Triggers.First());

            // Generate function.json
            var functionJsonContent = $@"
{{
  ""bindings"": [
    {{
      ""authLevel"": ""function"",
      ""type"": ""{bindingType}"",
      ""direction"": ""{bindingDirection}"",
      ""name"": ""{bindingName}""
      {bindingProperties}
    }}
  ],
  ""scriptFile"": ""../dist/{functionName}/index.js""
}}
";
            await File.WriteAllTextAsync(Path.Combine(functionPath, "function.json"), functionJsonContent.Trim());

            // Generate index.ts
            var srcPath = Path.Combine(projectPath, "src", functionName);
            Directory.CreateDirectory(srcPath);
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();

            var handlerContent = $@"
import {{ AzureFunction, Context, HttpRequest }} from ""@azure/functions""
// import {{ {handlerClassName} }} from '../../logic/handlers'; // Developer must configure path
// import {{ {payload.TypeFullName} }} from '../../logic/dtos'; // Developer must configure path

// Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}

const {ToCamelCase(functionName)}: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {{
    context.log('HTTP trigger function processed a request.');
    
    // In a real application, DI would provide the handler instance
    // const handler = new {handlerClassName}();
    const payload: {payload.TypeFullName} = req.body;

    try {{
        // Weave hook logic here
        
        // await handler.{ToCamelCase(functionName)}(payload);

        context.res = {{
            status: 200,
            body: ""Request processed successfully.""
        }};
    }} catch (error) {{
        context.log.error('An error occurred:', error);
        context.res = {{
            status: 500,
            body: ""An error occurred during execution.""
        }};
    }}
}};

export default {ToCamelCase(functionName)};
";
            await File.WriteAllTextAsync(Path.Combine(srcPath, "index.ts"), handlerContent.Trim());
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
        {
            _logger.LogInfo("Assembling TypeScript test harness project...");
            var testsPath = Path.Combine(testProjectPath, "tests");
            Directory.CreateDirectory(testsPath);

            var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
            var relevantTestFiles = Directory.GetFiles(testSourcePath, $"*{handlerClassNameShort}.test.ts", SearchOption.AllDirectories);
            foreach (var testFile in relevantTestFiles)
            {
                File.Copy(testFile, Path.Combine(testsPath, Path.GetFileName(testFile)), true);
            }

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                await GenerateSingleTestHarnessFileAsync(triggerMethod, testsPath);
            }
        }

        private async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var functionName = triggerMethod.MethodName;
            var handlerModuleName = ToCamelCase(functionName);
            var businessLogicModuleName = ToCamelCase(_blueprint.HandlerClassFullName.Split('.').Last());
            var harnessFileName = $"{functionName}.harness.test.ts";

            var harnessContent = $@"
import {handlerModuleName} from '../../src/{functionName}/index';
// Mock the business logic module - developer needs to configure the path
// jest.mock('../../logic/handlers');
// import {{ {businessLogicModuleName} }} from '../../logic/handlers';

// Auto-generated by 3SC DataLink. This test skeleton is designed to fail by default.
describe('{functionName} harness', () => {{

    let context: any;

    beforeEach(() => {{
        context = {{ log: jest.fn() }};
    }});

    it('should invoke the business logic handler', async () => {{
        // This test will fail here until you implement the mock setups and assertions.
        throw new Error('Test not yet implemented. Please configure mocks and add assertions, then remove this line.');

        /* --- EXAMPLE IMPLEMENTATION ---
        // Arrange
        const mockMethod = {businessLogicModuleName}.prototype.{ToCamelCase(triggerMethod.MethodName)};
        
        const request = {{
            body: {{ key: 'value' }}
        }};
        
        // Act
        // await {handlerModuleName}(context, request);
        
        // Assert
        // expect(mockMethod).toHaveBeenCalledTimes(1);
        // expect(context.res.status).toBe(200);
        */
    }});
}});
";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private (string Type, string Direction, string Name, string Properties) GetBindingDetails(TriggerDefinition trigger)
        {
            switch (trigger.Type)
            {
                case "Http":
                    var route = trigger.Name.TrimStart('/');
                    var method = trigger.Properties.GetValueOrDefault("Method", "post")?.ToLowerInvariant();
                    var properties = $@",
      ""route"": ""{route}"",
      ""methods"": [
        ""{method}""
      ]";
                    return ("httpTrigger", "in", "req", properties);
                case "AzureServiceBusQueue":
                    properties = $@",
      ""queueName"": ""{trigger.Name}"",
      ""connection"": ""ServiceBusConnection""";
                    return ("serviceBusTrigger", "in", "myQueueItem", properties);
                default:
                    throw new NotSupportedException($"Trigger type '{trigger.Type}' is not supported for TypeScript Azure Functions generation.");
            }
        }

        private string ToCamelCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return char.ToLowerInvariant(input[0]) + input.Substring(1);
        }
    }
}