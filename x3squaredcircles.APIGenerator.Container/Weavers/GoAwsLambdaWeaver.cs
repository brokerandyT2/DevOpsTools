using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;

namespace x3squaredcircles.DataLink.Container.Weavers
{
    public class GoAwsLambdaWeaver : GoWeaverBase
    {
        public GoAwsLambdaWeaver(IAppLogger logger, ServiceBlueprint blueprint)
            : base(logger, blueprint) { }

        public override async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            var moduleName = _blueprint.ServiceName.ToLowerInvariant();
            var goModContent = $@"
module {moduleName}

go 1.21

require (
    github.com/aws/aws-lambda-go v1.47.0
)";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "go.mod"), goModContent.Trim());

            var destLogicPath = Path.Combine(projectPath, "business_logic");
            CopyDirectory(logicSourcePath, destLogicPath);
        }

        public override Task GenerateStartupFileAsync(string projectPath)
        {
            return Task.CompletedTask;
        }

        public override async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var resources = new StringBuilder();

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                var eventSource = triggerMethod.DslAttributes.First(a => a.Name == "EventSource");
                var (eventType, eventProperties) = ParseUrnForSam(eventSource.Arguments["EventUrn"]);

                var handlerPath = triggerMethod.MethodName; // For Go, the handler is the compiled binary name

                resources.AppendLine($@"  {triggerMethod.MethodName}Function:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Zip
      CodeUri: .
      Handler: {handlerPath}
      Runtime: go1.x
      Architectures: [ x86_64 ]
      Events:
        Trigger:
          Type: {eventType}
          Properties:
{eventProperties}");
            }

            var samTemplateContent = $@"
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  {_blueprint.ServiceName} - Auto-generated by 3SC DataLink from source version {_blueprint.Metadata.SourceVersionTag}

Resources:
{resources.ToString().TrimEnd()}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "template.yaml"), samTemplateContent.Trim());
        }

        public override async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var mainGoFilePath = Path.Combine(projectPath, $"{triggerMethod.MethodName}.go");
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerPackageName = ToSnakeCase(handlerClassName);

            var payloadParam = triggerMethod.Parameters.FirstOrDefault(p => !p.IsBusinessLogicDependency);
            if (payloadParam == null) throw new DataLinkException(ExitCode.CodeGenerationFailed, "GO_PAYLOAD_NOT_FOUND", $"Method '{triggerMethod.MethodName}' requires a payload parameter.");

            var (awsEventType, payloadExtractionLogic) = GetAwsEventTypeAndLogic(payloadParam.TypeFullName);

            var mainGoContent = $@"
package main

import (
    ""context""
    ""encoding/json""
    ""fmt""

    ""github.com/aws/aws-lambda-go/lambda""
    ""github.com/aws/aws-lambda-go/events""

    logic ""{_blueprint.ServiceName.ToLowerInvariant()}/business_logic"" // Assumes Go module path
)

// In a real application, a DI container would manage dependencies.
var handlerInstance = logic.New{handlerClassName}() // Assumes a constructor function `New...` exists

func {triggerMethod.MethodName}Handler(ctx context.Context, event {awsEventType}) (events.APIGatewayProxyResponse, error) {{
    fmt.Println(""Function '{triggerMethod.MethodName}' triggered."")

    var payload logic.{payloadParam.TypeFullName}
    {payloadExtractionLogic}

    // Invoke the business logic.
    result, err := handlerInstance.{triggerMethod.MethodName}(payload)
    if err != nil {{
        fmt.Println(""Error from business logic:"", err)
        return events.APIGatewayProxyResponse{{Body: ""Error processing request"", StatusCode: 500}}, nil
    }}

    responseBody, _ := json.Marshal(result)
    return events.APIGatewayProxyResponse{{Body: string(responseBody), StatusCode: 200}}, nil
}}

func main() {{
    lambda.Start({triggerMethod.MethodName}Handler)
}}
";
            await File.WriteAllTextAsync(mainGoFilePath, mainGoContent.Trim());
        }

        protected override async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var harnessFileName = $"{ToSnakeCase(triggerMethod.MethodName)}_harness_test.go";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), "// TODO: Implement Go AWS test harness");
        }

        private (string eventType, string payloadLogic) GetAwsEventTypeAndLogic(string payloadType)
        {
            if (payloadType.Contains("S3Event"))
                return ("events.S3Event", "payload = event");
            if (payloadType.Contains("SQSEvent"))
                return ("events.SQSEvent", "json.Unmarshal([]byte(event.Records[0].Body), &payload)");

            return ("events.APIGatewayProxyRequest", "json.Unmarshal([]byte(event.Body), &payload)");
        }

        private (string eventType, string eventProperties) ParseUrnForSam(string urn)
        {
            var parts = urn.Split(':');
            if (parts.Length < 4) return ("Api", "            Path: /invalid-urn\n            Method: get");
            var service = parts[1].ToLowerInvariant();
            var resource = parts[2];
            var action = string.Join(":", parts.Skip(3));
            switch (service)
            {
                case "s3": return ("S3", $"            Bucket: {resource}\n            Events: s3:{action}");
                case "sqs": return ("SQS", $"            Queue: {resource}");
                case "apigateway": return ("Api", $"            Path: {resource}\n            Method: {action.ToLowerInvariant()}");
                default: return ("Api", $"            Path: /unsupported-service\n            Method: get");
            }
        }
    }
}