using Microsoft.AspNetCore.DataProtection.KeyManagement;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a Go OCI Functions project using the Fn Project FDK.
    /// </summary>
    public class GoOciFunctionsWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public GoOciFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            // For Go, the primary project file is go.mod.
            var moduleName = _blueprint.ServiceName.ToLowerInvariant();
            var goModContent = $@"
module {moduleName}

go 1.21

require (
    github.com/fnproject/fdk-go v0.0.28
)
";
            var filePath = Path.Combine(projectPath, "go.mod");
            await File.WriteAllTextAsync(filePath, goModContent.Trim());
            _logger.LogDebug($"Generated go.mod file: {filePath}");
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            // The Go FDK uses func.go as the entry point, which is generated in GenerateFunctionFileAsync.
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            // Generate the func.yaml file required by the Fn Project CLI.
            var triggerMethod = _blueprint.TriggerMethods.First();
            var funcYamlContent = $@"
schema_version: 20180708
name: {_blueprint.ServiceName.ToLowerInvariant()}
version: {_blueprint.Metadata.SourceVersionTag.TrimStart('v')}
runtime: go
entrypoint: ./func
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "func.yaml"), funcYamlContent.Trim());
            _logger.LogDebug($"Generated func.yaml file: {projectPath}");

            // Generate the Dockerfile for building the OCI Function container.
            var dockerfileContent = $@"
# Auto-generated by 3SC DataLink
# Source Version: {_blueprint.Metadata.SourceVersionTag}
FROM fnproject/go:1.21-dev as build-stage
WORKDIR /function
# TODO: Add steps to include the developer's business logic package
ADD . /go/src/func/
RUN cd /go/src/func/ && go mod tidy && go build -o func

FROM fnproject/go:1.21
WORKDIR /function
COPY --from=build-stage /go/src/func/func /function/
ENTRYPOINT [""./func""]
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "Dockerfile"), dockerfileContent.Trim());
            _logger.LogDebug($"Generated Dockerfile for OCI: {projectPath}");
        }
        private string ToSnakeCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return string.Concat(input.Select((x, i) => i > 0 && char.IsUpper(x) ? "_" + x.ToString() : x.ToString())).ToLower();
        }
        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            // For OCI Go functions, we generate a single func.go file that contains the main handler.
            var handlerFilePath = Path.Combine(projectPath, "func.go");
            if (File.Exists(handlerFilePath))
            {
                _logger.LogDebug("func.go already exists, skipping generation.");
                return;
            }

            var payload = triggerMethod.Parameters.First(p => p.IsPayload);
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerPackage = ToSnakeCase(handlerClassName);

            var funcGoContent = $@"
package main

import (
	""context""
	""encoding/json""
	""fmt""
	""log""

	""github.com/fnproject/fdk-go""

    // TODO: Developer must ensure their business logic package is available.
	// ""github.com/my-org/my-project/business_logic/{handlerPackage}""
)

// Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}
// Source Version: {_blueprint.Metadata.SourceVersionTag}

func main() {{
	fdk.Handle(fdk.HandlerFunc(myHandler))
}}

// In a real application, a struct would hold dependencies initialized via DI.
// var handler = {handlerPackage}.New{handlerClassName}()

func myHandler(ctx context.Context, in []byte) ([]byte, error) {{
	log.Println(""Function '{triggerMethod.MethodName}' triggered."")

	var payload {payload.TypeFullName} // Assuming DTO struct is available
	err := json.Unmarshal(in, &payload)
	if err != nil {{
		log.Println(""Error unmarshalling payload:"", err)
		return nil, fmt.Errorf(""invalid request body: %w"", err)
	}}

    // Weave [Requires] hooks here.
    // Weave [RequiresLogger] OnInbound hooks here.

    // Invoke the business logic.
    // err = handler.{triggerMethod.MethodName}(payload)
    // if err != nil {{
    //     // Weave [RequiresLogger] OnError hooks here.
    //     return nil, err
    // }}
	
	response := map[string]string{{""message"": ""Request processed successfully""}}
    
	return json.Marshal(response)
}}
";
            await File.WriteAllTextAsync(handlerFilePath, funcGoContent.Trim());
_logger.LogDebug($"Generated Go OCI handler file: {handlerFilePath}");
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
{
    _logger.LogInfo("Assembling Go OCI test harness project...");
    var testsPath = Path.Combine(testProjectPath, "tests");
    Directory.CreateDirectory(testsPath);

    var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
    var relevantTestFiles = Directory.GetFiles(testSourcePath, $"*{ToSnakeCase(handlerClassNameShort)}_test.go", SearchOption.AllDirectories);
    foreach (var testFile in relevantTestFiles)
    {
        File.Copy(testFile, Path.Combine(testsPath, Path.GetFileName(testFile)), true);
    }

    await GenerateSingleTestHarnessFileAsync(testsPath);
}

private async Task GenerateSingleTestHarnessFileAsync(string testPackagePath)
{
    var harnessFileName = $"func_harness_test.go";
    var triggerMethod = _blueprint.TriggerMethods.First();

    var harnessContent = $@"
package main_test

import (
	""context""
	""encoding/json""
	""testing""

	""github.com/stretchr/testify/assert""

	// main ""{_blueprint.ServiceName.ToLowerInvariant()}"" // Import the generated main package
    // ""{_blueprint.ServiceName.ToLowerInvariant()}/mocks"" // Assuming mock package
)

// Auto-generated by 3SC DataLink. This test skeleton is designed to fail by default.
func TestMyHandler_Harness(t *testing.T) {{
	t.Fatal(""Test not yet implemented. Please configure mock setups and add assertions."")

    /* --- EXAMPLE IMPLEMENTATION ---
    // Arrange
    // mockCtrl := gomock.NewController(t)
    // defer mockCtrl.Finish()
    // mockHandler := mocks.NewMockMyHandler(mockCtrl)
    
    // // This requires a way to inject the mock into the handler.
    // main.SetHandler(mockHandler)

    // mockHandler.EXPECT().{triggerMethod.MethodName}(gomock.Any()).Return(nil)
    
    payload := map[string]string{{""key"": ""value""}}
    input, _ := json.Marshal(payload)

    // Act
    // output, err := main.myHandler(context.Background(), input)

    // Assert
    // assert.NoError(t, err)
    // assert.Contains(t, string(output), ""Request processed successfully"")
    */
}}";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }
        
       
    }
}
