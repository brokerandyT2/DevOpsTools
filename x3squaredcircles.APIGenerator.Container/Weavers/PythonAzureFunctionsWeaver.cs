using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;
using x3squaredcircles.DataLink.Container.Weavers;

namespace x3squaredcircles.datalink.container.Weavers
{
    /// <summary>
    /// Implements ILanguageWeaver for generating a Python v2 programming model Azure Functions project.
    /// </summary>
    public class PythonAzureFunctionsWeaver : ILanguageWeaver
    {
        private readonly IAppLogger _logger;
        private readonly ServiceBlueprint _blueprint;

        public PythonAzureFunctionsWeaver(IAppLogger logger, ServiceBlueprint blueprint)
        {
            _logger = logger;
            _blueprint = blueprint;
        }

        public async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            // Python projects use requirements.txt for dependencies.
            var uniqueTriggers = _blueprint.TriggerMethods
                .SelectMany(tm => tm.Triggers)
                .Select(t => t.Type)
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            var requirements = new StringBuilder();
            requirements.AppendLine("# Auto-generated by 3SC DataLink");
            requirements.AppendLine("# Add any business logic dependencies from your source repository here.");
            requirements.AppendLine("azure-functions");

            if (uniqueTriggers.Contains("Http"))
            {
                // Included in azure-functions
            }
            if (uniqueTriggers.Contains("AzureServiceBusQueue"))
            {
                requirements.AppendLine("azure-functions-durable"); // Service bus is part of durable extensions
            }

            var filePath = Path.Combine(projectPath, "requirements.txt");
            await File.WriteAllTextAsync(filePath, requirements.ToString());
            _logger.LogDebug($"Generated requirements.txt file: {filePath}");
        }

        public Task GenerateStartupFileAsync(string projectPath)
        {
            // The Python v2 model uses a single function_app.py file for defining the app and triggers,
            // which serves as the primary startup/entry point. This is generated in GenerateFunctionFileAsync.
            _logger.LogDebug("Python Azure Functions startup logic will be generated in function_app.py.");
            return Task.CompletedTask;
        }

        public async Task GeneratePlatformFilesAsync(string projectPath)
        {
            // Standard host.json for Azure Functions
            var hostJsonContent = @"{
  ""version"": ""2.0"",
  ""logging"": {
    ""applicationInsights"": {
      ""samplingSettings"": {
        ""isEnabled"": true,
        ""excludedTypes"": ""Request""
      }
    }
  },
  ""extensionBundle"": {
    ""id"": ""Microsoft.Azure.Functions.ExtensionBundle"",
    ""version"": ""[4.*, 5.0.0)""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "host.json"), hostJsonContent.Trim());

            // Standard local.settings.json
            var settingsJsonContent = @"{
  ""IsEncrypted"": false,
  ""Values"": {
    ""AzureWebJobsStorage"": ""UseDevelopmentStorage=true"",
    ""FUNCTIONS_WORKER_RUNTIME"": ""python""
  }
}";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "local.settings.json"), settingsJsonContent.Trim());
            _logger.LogDebug($"Generated host.json and local.settings.json at: {projectPath}");
        }

        public async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            // The Python v2 model encourages a single function_app.py for all triggers.
            // We will generate this file once, containing all discovered triggers for the service.
            var functionAppFilePath = Path.Combine(projectPath, "function_app.py");
            if (File.Exists(functionAppFilePath))
            {
                _logger.LogDebug("function_app.py already exists, skipping generation to avoid overwriting.");
                return;
            }

            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerModuleName = ToSnakeCase(handlerClassName);

            var sb = new StringBuilder();
            sb.AppendLine("# -*- coding: utf-8 -*-");
            sb.AppendLine($"# Auto-generated by 3SC DataLink at {DateTime.UtcNow:O}");
            sb.AppendLine($"# Source Version: {_blueprint.Metadata.SourceVersionTag}");
            sb.AppendLine();
            sb.AppendLine("import azure.functions as func");
            sb.AppendLine("import logging");
            sb.AppendLine("import json");
            sb.AppendLine();
            sb.AppendLine($"# from business_logic.{handlerModuleName} import {handlerClassName}");
            sb.AppendLine();
            sb.AppendLine("app = func.FunctionApp()");
            sb.AppendLine();
            sb.AppendLine("# In a real application, dependency injection would be initialized here.");
            sb.AppendLine($"# {handlerModuleName} = {handlerClassName}()");
            sb.AppendLine();

            foreach (var method in _blueprint.TriggerMethods)
            {
                var trigger = method.Triggers.First();
                var (triggerDecorator, triggerVariable) = GetTriggerDecorator(trigger, method.MethodName);

                sb.AppendLine($"@{triggerDecorator}");
                sb.AppendLine($"def {method.MethodName}({triggerVariable}):");
                sb.AppendLine($"    logging.info('Python trigger function `{method.MethodName}` processed a request.')");
                sb.AppendLine();
                sb.AppendLine("    try:");
                sb.AppendLine("        # This is where the generated shim logic would exist.");
                sb.AppendLine("        # It would deserialize the payload and call the business logic.");
                sb.AppendLine($"        # {handlerModuleName}.{ToSnakeCase(method.MethodName)}(payload)");
                sb.AppendLine();
                sb.AppendLine("        return func.HttpResponse(\"Request processed successfully.\", status_code=200)");
                sb.AppendLine("    except Exception as e:");
                sb.AppendLine("        logging.error(f\"An error occurred: {e}\")");
                sb.AppendLine("        return func.HttpResponse(\"An error occurred during execution.\", status_code=500)");
                sb.AppendLine();
            }

            await File.WriteAllTextAsync(functionAppFilePath, sb.ToString());
            _logger.LogDebug($"Generated Python function app file: {functionAppFilePath}");
        }

        public async Task AssembleTestHarnessAsync(string testSourcePath, string testProjectPath, string mainProjectPath)
        {
            _logger.LogInfo("Assembling Python test harness project...");
            var testsPath = Path.Combine(testProjectPath, "tests");
            Directory.CreateDirectory(testsPath);

            var handlerClassNameShort = _blueprint.HandlerClassFullName.Split('.').Last();
            var relevantTestFiles = Directory.GetFiles(testSourcePath, $"test_*{ToSnakeCase(handlerClassNameShort)}.py", SearchOption.AllDirectories);
            foreach (var testFile in relevantTestFiles)
            {
                File.Copy(testFile, Path.Combine(testsPath, Path.GetFileName(testFile)), true);
            }

            var testRequirementsContent = @"# Auto-generated by 3SC DataLink
pytest
mock
azure-functions
";
            await File.WriteAllTextAsync(Path.Combine(testProjectPath, "requirements.txt"), testRequirementsContent.Trim());

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                await GenerateSingleTestHarnessFileAsync(triggerMethod, testsPath);
            }
        }

        private async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var harnessFileName = $"test_{triggerMethod.MethodName}_harness.py";
            var businessLogicModuleName = ToSnakeCase(_blueprint.HandlerClassFullName.Split('.').Last());

            var harnessContent = $@"
# Auto-generated by 3SC DataLink. This test skeleton is designed to fail by default.
import unittest
import pytest
from unittest import mock
import azure.functions as func

# It's assumed that the 'src' directory of the main project is on the python path
import function_app

class Test{triggerMethod.MethodName}Harness(unittest.TestCase):

    @mock.patch('function_app.{businessLogicModuleName}') # Mock the business logic module
    def test_{ToSnakeCase(triggerMethod.MethodName)}_invokes_business_logic(self, mock_business_logic_module):
        """"""
        This test verifies that the generated shim correctly invokes the business logic.
        """"""
        # This test will fail here until you implement the mock setups and assertions.
        pytest.fail(""Test not yet implemented. Please configure mocks and add assertions, then remove this line."")

        # --- EXAMPLE IMPLEMENTATION ---
        # # Arrange
        # mock_handler_instance = mock_business_logic_module.{_blueprint.HandlerClassFullName.Split('.').Last()}.return_value
        # 
        # req = func.HttpRequest(
        #     method='POST',
        #     body=b'{"\"key\"": ""value""}',
        #     url='/api/{triggerMethod.MethodName}'
        # )
        #
        # # Act
        # response = function_app.{triggerMethod.MethodName}(req)
        #
        # # Assert
        # self.assertEqual(response.status_code, 200)
        # mock_handler_instance.{ToSnakeCase(triggerMethod.MethodName)}.assert_called_once()
";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private (string decorator, string triggerVariable) GetTriggerDecorator(TriggerDefinition trigger, string functionName)
        {
            switch (trigger.Type)
            {
                case "Http":
                    var route = trigger.Name.TrimStart('/');
                    var method = trigger.Properties.GetValueOrDefault("Method", "post")?.ToLowerInvariant();
                    return ($"app.route(route=\"{route}\", methods=[func.HttpMethod.{method.ToUpper()}], auth_level=func.AuthLevel.FUNCTION)", "req: func.HttpRequest");
                case "AzureServiceBusQueue":
                    return ($"app.service_bus_queue_trigger(arg_name=\"msg\", queue_name=\"{trigger.Name}\", connection=\"ServiceBusConnection\")", "msg: func.ServiceBusMessage");
                case "Cron":
                    return ($"app.schedule(schedule=\"{trigger.Name}\", arg_name=\"myTimer\", run_on_startup=True)", "myTimer: func.TimerRequest");
                default:
                    throw new NotSupportedException($"Trigger type '{trigger.Type}' is not supported for Python Azure Functions generation.");
            }
        }

        private string ToSnakeCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "unknown";
            return string.Concat(input.Select((x, i) => i > 0 && char.IsUpper(x) ? "_" + x.ToString() : x.ToString())).ToLower();
        }
    }
}