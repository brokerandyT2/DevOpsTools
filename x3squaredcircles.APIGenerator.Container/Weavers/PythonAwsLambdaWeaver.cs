using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.datalink.container.Models;
using x3squaredcircles.datalink.container.Services;

namespace x3squaredcircles.DataLink.Container.Weavers
{
    public class PythonAwsLambdaWeaver : ScriptingWeaverBase
    {
        public PythonAwsLambdaWeaver(IAppLogger logger, ServiceBlueprint blueprint)
            : base(logger, blueprint) { }

        protected override string GetDeveloperTestFilePattern(string handlerClassNameShort) => $"test_*{ToSnakeCase(handlerClassNameShort)}.py";
        protected override string GetHandlerFileName() => "handler.py";

        public override async Task GenerateProjectFileAsync(string projectPath, string logicSourcePath)
        {
            // For Python, the main project file is requirements.txt.
            // We can also find the developer's requirements and merge them.
            var devRequirements = string.Empty;
            var devReqFile = Directory.GetFiles(logicSourcePath, "requirements.txt", SearchOption.AllDirectories).FirstOrDefault();
            if (devReqFile != null)
            {
                devRequirements = await File.ReadAllTextAsync(devReqFile);
            }

            var requirementsContent = $@"# Auto-generated by 3SC DataLink
# Developer-provided dependencies:
{devRequirements}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "requirements.txt"), requirementsContent.Trim());

            // Also copy the developer's business logic source code into the generated project.
            var destLogicPath = Path.Combine(projectPath, "business_logic");
            CopyDirectory(logicSourcePath, destLogicPath);
        }

        public override Task GenerateStartupFileAsync(string projectPath)
        {
            // Python on AWS Lambda does not have a separate startup file.
            return Task.CompletedTask;
        }

        public override async Task GeneratePlatformFilesAsync(string projectPath)
        {
            var resources = new StringBuilder();

            foreach (var triggerMethod in _blueprint.TriggerMethods)
            {
                var eventSource = triggerMethod.DslAttributes.First(a => a.Name == "EventSource");
                var (eventType, eventProperties) = ParseUrnForSam(eventSource.Arguments["EventUrn"]);

                var handlerPath = GetHandlerPath(triggerMethod.MethodName);

                resources.AppendLine($@"  {triggerMethod.MethodName}Function:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Zip
      CodeUri: .
      Handler: {handlerPath}
      Runtime: python3.11
      Architectures: [ x86_64 ]
      Events:
        Trigger:
          Type: {eventType}
          Properties:
{eventProperties}");
            }

            var samTemplateContent = $@"
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  {_blueprint.ServiceName} - Auto-generated by 3SC DataLink from source version {_blueprint.Metadata.SourceVersionTag}

Resources:
{resources.ToString().TrimEnd()}
";
            await File.WriteAllTextAsync(Path.Combine(projectPath, "template.yaml"), samTemplateContent.Trim());
        }

        public override async Task GenerateFunctionFileAsync(TriggerMethod triggerMethod, string projectPath)
        {
            var handlerFilePath = Path.Combine(projectPath, GetHandlerFileName());
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var handlerModuleName = ToSnakeCase(handlerClassName);
            var handlerVarName = ToSnakeCase(handlerClassName);
            var businessLogicCallParams = string.Join(", ", triggerMethod.Parameters.Select(p => p.Name));

            var sb = new StringBuilder();
            if (!File.Exists(handlerFilePath))
            {
                // Create the file shell if it's the first time.
                sb.AppendLine("# -*- coding: utf-8 -*-");
                sb.AppendLine("# Auto-generated by 3SC DataLink");
                sb.AppendLine("import json");
                sb.AppendLine();
                // This assumes the business logic is in a 'business_logic' subfolder.
                sb.AppendLine($"from business_logic.{handlerModuleName} import {handlerClassName}");
                sb.AppendLine();
                sb.AppendLine("# In a real application, a single instance of the handler would be created here.");
                sb.AppendLine($"handler_instance = {handlerClassName}()");
                sb.AppendLine();
            }

            sb.AppendLine($"def {triggerMethod.MethodName}(event, context):");
            sb.AppendLine("    try:");
            sb.AppendLine("        # This is a simplified payload extraction. A full implementation would");
            sb.AppendLine("        # need to map different event sources (S3, SQS) to the expected DTO.");
            sb.AppendLine("        payload = json.loads(event.get('body', '{}'))");
            sb.AppendLine($"        result = handler_instance.{ToSnakeCase(triggerMethod.MethodName)}(**payload)");
            sb.AppendLine("        return { 'statusCode': 200, 'body': json.dumps(result or {{'message': 'Success'}}) }");
            sb.AppendLine("    except Exception as e:");
            sb.AppendLine("        print(f\"ERROR in {triggerMethod.MethodName}: {{e}}\")");
            sb.AppendLine("        return { 'statusCode': 500, 'body': json.dumps({{'message': 'An error occurred.'}}) }");
            sb.AppendLine();

            await File.AppendAllTextAsync(handlerFilePath, sb.ToString());
        }

        protected override async Task GenerateSingleTestHarnessFileAsync(TriggerMethod triggerMethod, string testPackagePath)
        {
            var handlerClassName = _blueprint.HandlerClassFullName.Split('.').Last();
            var businessLogicModuleName = ToSnakeCase(handlerClassName);
            var harnessFileName = $"test_{triggerMethod.MethodName}_harness.py";

            var harnessContent = $@"
# Auto-generated by 3SC DataLink.
import json
import pytest
from unittest import mock

# It is assumed that the 'src' directory containing handler.py is on the python path
import handler

class Test{triggerMethod.MethodName}Harness:

    @mock.patch('handler.{businessLogicModuleName}')
    def test_{ToSnakeCase(triggerMethod.MethodName)}_invokes_business_logic(self, mock_business_logic_module):
        # Arrange
        # This mocks the class constructor to return a mock instance
        mock_handler_instance = mock_business_logic_module.{handlerClassName}.return_value
        
        event = {{ 'body': json.dumps({{'key': 'value'}}) }}
        context = None

        # Act
        result = handler.{triggerMethod.MethodName}(event, context)

        # Assert
        assert result['statusCode'] == 200
        mock_handler_instance.{ToSnakeCase(triggerMethod.MethodName)}.assert_called_once()
";
            await File.WriteAllTextAsync(Path.Combine(testPackagePath, harnessFileName), harnessContent.Trim());
        }

        private void CopyDirectory(string sourceDir, string destinationDir)
        {
            var dir = new DirectoryInfo(sourceDir);
            if (!dir.Exists) return;

            Directory.CreateDirectory(destinationDir);
            foreach (FileInfo file in dir.GetFiles())
            {
                string targetFilePath = Path.Combine(destinationDir, file.Name);
                file.CopyTo(targetFilePath);
            }
            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                if (subDir.Name != "tests" && subDir.Name != ".git") // Avoid copying tests or git repo
                {
                    string newDestinationDir = Path.Combine(destinationDir, subDir.Name);
                    CopyDirectory(subDir.FullName, newDestinationDir);
                }
            }
        }
    }
}